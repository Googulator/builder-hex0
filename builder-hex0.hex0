#
# Builder-Hex0 is a small bootable machine image which has
# the ability to compile hex0 code. It is also written in hex0
# and so it can build itself if provided with its own source code.
#
# hex0 is a "language" for binary encoding in hexadecimal
# with support for comments.

# --- stage 1
# _start
# [global data]
# halt
# reboot
#
# console_putc_16
# console_put_hex_16
# console_puts_16
#
# get_partition_start_16
# get_drive_geometry
# next_sector
# read_sectors_16
#
# mbr_main

# --- stage 2
# kern_main
# [GDT data]
# start_32bit_main
# setup_interrupt_handlers
# stub_interrupt_handler
# enter_16bit_real
# resume_32bit_mode
#
# console_putc
# console_put_hex
# console_puts
# get_partition_start
# read_sectors
#
# syscall_interrupt_handler
# handle_syscall_open
# handle_syscall_read
#
# --- "User Mode"
# app_main


#------------------------------------------------------------
# Memory:
# 800000 -        processes
# 500000 - 7FFFFF files 3M
# 401800 - 4FFC00 file names 6..1023
# 401400 - 4017FF file name 5
# 401000 - 4013FF file name 4
# 400010 - 400FF0 file lengths 4*1022
# 380000 - 3FFFFF io buffers/free
# 300010 - 300FF0 start address of files 4 * 1022
# 200800 - 2FFFFF cmd arg3..1024 (1022 args * 1K)
# 200400 - 2007FF cmd arg2 (1K)
# 200000 - 2003FF cmd arg1 (1K)
# 100000 - 1FFFF0 32 bit stack (1M)
#  9FC00 -  FFFFF BIOS
#  20000 -  9FBFF device buffers
#  10800 -  1FFFF opened file descriptors (8 bytes each)
#  10000 -  10800 interrupt table
#   A000 -   A1FF sector read buffer - 16bit
#   7C00 -   8600 code
#   7B00 -   7BFF Saved 32 bit registers while in 16 bit mode
# < 7B00          real mode stack
#------------------------------------------------------------


# ------------------------------------------------------------
# Stub Entry Point
#
# boot drive is in dl
#
#[7C00][13]
#:_start

# We cannot be sure the registers are initialized to zero so we
# do that first. We far jump to mbr_main in order to set CS.
31 C0           # xor ax, ax
8E D8           # COPY_AX_to_DS
8E C0           # COPY_AX_to_ES
FA              # cli               ;  cli/sti necessary on 8088
8E D0           # COPY_AX_to_SS
BC 00 7B        # mov sp, 0x7B00
FB              # sti
FC              # CLD ; clear direction flag

EA 48 7D 00 00  # jmp mbr_main


# ------------------------------------------------------------
# Global Data
#[7C13]
80     # boot_drive
0F     # boot drive max_head  0..15 
3F     # boot drive num_sectors / track (1..63)


#[7C16][0B]
#H  a  l  t  i  n  g  .  .  . \0
48 61 6C 74 69 6E 67 2E 2E 2E 00

#[7C21][0D]
#R  e  b  o  o  t  i  n  g  .  .  . \0
52 65 62 6F 6F 74 69 6E 67 2E 2E 2E 00

#[7C2E][11]
#N  o     s  o  u  r  c  e    f   o  u  n  d  . \0
4E 6F 20 73 6F 75 72 63 65 20 66 6F 75 6E 64 2E 00

#[7C3F][10]
#B  u  i  l  d     f  i  n  i  s  h  e  d  . \0
42 75 69 6C 64 20 66 69 6E 69 73 68 65 64 2E 00

#[7C4F][8]
# available
00 00 00 00 00 00 00 00


# ------------------------
#[7C57]
#:halt
#
F4      # hlt
EB FD   # jmp halt

# ------------------------
#[7C5A]
#:reboot
#
EA F0 FF 00 F0  # ljmp $F000:FFF0

# ------------------------
#[7C5F][16]
#:console_putc_16(al=c)
#
# Note: with QEMU+Seabios this does not flush the last character or
# CRLF of a line until the first character is output on the next line
# and that character cannot be another CRLF.
53        # PUSH_BX
50        # PUSH_AX

# Prepare to use BIOS tty output interrupt.
# Specify text page 00, 0 black background, 7 light grey text
BB 00 07  # LOADI16_BX 0007
# Specify the `write character` BIOS routine
B4 0E     # LOADI8_AH  0E

3C 0A     # cmp al, 0A
75 06     # jne regular

# convert LF to CR LF for BIOS output
B0 0D     # mov al, 0D
CD 10     # INT_10
B0 0A     # mov al, 0A

#:regular:
CD 10     # INT_10

58        # POP_AX
5B        # POP_BX
CB        # RETF

#[7C75][31]
#:console_put_hex_16(al=byte)
50              # PUSH_AX

24 F0           # and al, 0xF0
C0 E8 04        # shr al, 4
3C 09           # cmp al, 9
7F 04           # jg alpha
#10

#numeral:
04 30           # add al, 0x30
EB 02           # jmp print1

#alpha:
04 37           # add al, 0x37
#16

#print1:
9A 5F 7C 00 00  # CALL 00007C5F  call console_putc_16

58              # POP_AX        ; restore original al
50              # PUSH_AX       ;

24 0F           # and al, 0x0F
3C 09           # cmp al, 9
7F 04           # jg alpha
#29

#numeral:
04 30           # add al, 0x30
EB 02           # jmp print2

#alpha:
04 37           # add al, 0x37
#35

#print2:
9A 5F 7C 00 00  # CALL 00007C5F  call console_putc_16

B0 0A           # mov al, 0x0a
9A 5F 7C 00 00  # CALL 00007C5F  call console_putc_16

58              # POP_AX
CB              # retf


# ------------------------
#[7CA6][14]
#:console_puts_16 (ds:si = string)
#:puts_16_loop
#
AC              # lodsb  al=[ds:si++]
84 C0           # test al, al
74 07           # jz end_loop
9A 5F 7C 00 00  # CALL 00007C5F  call console_putc_16
EB F4           # jmp puts_16_loop

#:end_loop
B0 0A           # mov al, 0A
9A 5F 7C 00 00  # CALL 00007C5F  call console_putc_16
CB              # RETF


#[7CBA][16]
# ------------------------
#:get_partition_start_16(al=partition_num 1..4)
#returns:
# cx = cylinder/sector
# dh = head
#
50              # PUSH_AX
56              # PUSH_SI

BB 10 00        # mov bx, 0x0010     ; bx = partition_length
30 E4           # xor ah, ah
F7 E3           # mul bx             ; entry_offset = partition_num * bx
89 C6           # mov si, ax         ; si = entry_offset
BB AF 7D        # mov bx, 7DAF       ; bx = &partition_table[-1]
8A 30           # mov dh, [bx+si]    ; dh = head = partition_table[al][0]
8B 48 01        # mov cx, [bx+si+1]  ; cx = cyl/sector = partition_table[al][1]

5E              # POP_SI
58              # POP_AX
CB              # retf


#[7CD0][18]
# ------------------------
#:get_drive_geometry(dl)
#
06              # PUSH_ES
57              # PUSH_DI

# https://en.wikipedia.org/wiki/INT_13H#INT_13h_AH=08h:_Read_Drive_Parameters
31 FF           # xor di, di
8E C7           # mov es, di
B4 08           # mov ah, 8       ; get drive parameters
CD 13           # INT_13

88 36 14 7C     # mov 0x7C14, dh
80 E1 3F        # and cl, 0x3f
88 0E 15 7C     # mov 0x7C15, cl

5F              # POP_DI
07              # POP_ES
CB              # retf


#[7CE8][37]
# ------------------------
#:next_sector(cx=cylinder/sector, dh = head)
#
50              # PUSH_AX

88 C8           # mov al, cl          ; get sector number
24 3F           # and al, 0x3f
3C 3F           # cmp al, 0x3f        ; if sector_num == 63
74 04           # jz next_head        ;      goto next_head
FE C1           # inc cl              ; else sector_num++;
EB 28           # jmp cleanup

#next_head:
3A 36 14 7C     # cmp dh, [0x7C14]    ; if head_num == num_heads
74 09           # jz next_cylinder    ;      goto next_cyclinder
FE C6           # inc dh              ; else head_num++
80 E1 C0        # and cl, 0xc0        ;      sector_num = 1
FE C1           # inc cl              ;
EB 19           # jmp cleanup

#next_cylinder:
80 FD FF        # cmp ch, 0xff        ; if cylinder_low == 255
75 0B           # jnz next_cyl_high

#next_cyl_low:
30 F6           # xor dh, dh          ; head_num = 0
80 E1 C0        # and cl, 0xc0        ; sector_num = 0
81 C1 01 01     # add cx, 0x0101      ; cylinder_low++, sector_num++
EB 09           # jmp cleanup

#next_cyl_high:
30 F6           # xor dh, dh          ; head_num = 0
81 C1 C0 00     # and cx, 0x00C0      ; cylinder_low = 0, sector_num = 0
80 C1 41        # add cl, 0x41        ; cylinder_high++, sector_num++

#cleanup:
58              # POP_AX
CB              # retf


#[7D1F][29]
#:read_sectors_16(di = *dest_addr, cx=cylinder/sector, dh = head, ax=num_sectors)
#
# returns: di - next byte to write to
#          cx,dh - next disk sector to read from
#
50              # PUSH_AX
53              # PUSH_BX
56              # PUSH_SI

89 C6            # mov si, ax      ; si=num_sectors
89 FB            # mov bx, di      ; int 13 writes to bx

#:read_one_loop
8A 16 13 7C     # mov dl, [0x7C13] ; boot disk
B4 02           # mov ah, 2       ; rw mode = 02 (read)
B0 01           # mov al, 1       ; num_sectors
CD 13           # INT_13
72 F4           # jnc read_one_loop
3C 01           # cmp al, 1
75 F0           # jnz read_one_loop

#19
# advance and maybe continue
9A E8 7C 00 00  # call next_sector

# we read one sector, advance
81 C3 00 02     # add bx, 0x200
#28
4E              # dec si          ; num_sectors--
75 E4           # jnz read_one_loop

89 DF           # mov di, bx

5E              # POP_SI
5B              # POP_BX
58              # POP_AX
CB              # RETF
#37


#[7D48][19]
#:mbr_main (dl=boot_drive)
# Load the kernel and jump to it
88 16 13 7C     # mov 0x7C13, dl   ; save boot drive
9A D0 7C 00 00  # CALL get_drive_geometry()
BF 00 7E        # mov di, 0x7E00   ; place kernel after MBR in memory
B8 05 00        # mov ax, 0x0005   ; num_sectors = 5
B9 02 00        # LOADI16_CX 0002  ; cylinder = 0, sector_num = 0x02
B6 00           # LOADI8_DH 00     ; head = 0
9A 1F 7D 00 00  # call read_sectors_16
EA 00 7E 00 00  # JMP 00007E00  jmp kern_main


# ------------------------------------------------------------
# This is the rest of the MBR.
#
#[7D  ]
                  00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
#[7D80]
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
#[7DB0]
00 00 00 00 00 00 00 00 00 00 00 00 00 00

# Partition entry 1
#[7DBE]
# status inactive
00
# first head,sector[0..5]+cylinder[8..9],cylinder[0..7]
00 01 00
# type non-fs data
DA
# last head,sector[0..5]+cylinder[8..9],cylinder[0..7]
00 00 00
# LBA start
00 00 00 00
# Num sectors
00 00 00 00

# Partition entry 2
#[7DCE]
# status inactive
00
# first head,sector[0..5]+cylinder[8..9],cylinder[0..7]
00 02 00
# type "non-fs data"
DA
# last head,sector[0..5]+cylinder[8..9],cylinder[0..7]
00 00 00
# LBA start
00 00 00 00
# Num sectors
00 00 00 00

# Partition entry 3
# status inactive
00
# first head,sector[0..5]+cylinder[8..9],cylinder[0..7]
00 03 00
# type "non-fs data"
DA
# last head,sector[0..5]+cylinder[8..9],cylinder[0..7]
00 00 00
# LBA start
00 00 00 00
# Num sectors
00 00 00 00

# Partition entry 4
# status inactive
00
# first head,sector[0..5]+cylinder[8..9],cylinder[0..7]
00 07 00
# type "non-fs data"
DA
# last head,sector[0..5]+cylinder[8..9],cylinder[0..7]
00 00 00
# LBA start
00 00 00 00
# Num sectors
00 00 00 00

#[7DFE]
# This is the DOS/MBR identifier at offset 510:
55 AA

#------------------------------------------------------------
# The kernel entry point
#------------------------------------------------------------
#:kern_main
#[7E00][14]

EA 36 7E 00 00  # JMP jmp start_32bit_main

# alignment
90 90 90

#---------------------------------------------
# The Global Descriptor Table for 32 bit mode.
#---------------------------------------------
#[7E08]
#:GDT_start:
00 00 00 00 00 00 00 00

#7E10 [+08]
#:GDT_code32:
FF FF # limit 0:15
00 00 # base  0:15
00    # base 16:23
9A    # access byte 10011010b
      #   present=1 privilege=00 type=1
      #   code=1 conforming=0 readable=1 accessed=0
CF    # 11001111b
      #   granularity=1 32-bit-default=1 64-bit seg=0 AVL=0
00    #

#7E18 [+10]
#:GDT_data32:
FF FF # limit 0:15
00 00 # base  0:15
00    # base 16:23
92    # access byte 10010010b 
      #   present=1 privilege=00 type=1
      #   code=0 conforming=0 readable=1 accessed=0
CF    # flags, limit 16:19 11001111b  
      #   granularity=1 32-bit-default=1 64-bit seg=0 AVL=0
00    # base 24:31

#7E20 [+18]
#:GDT_code16:
FF FF # limit 0:15
00 00 # base  0:15
00    # base 16:23
9A    # access byte 10011010b
      #   present=1 privilege=00 type=1
      #   code=1 conforming=0 readable=1 accessed=0
8F    # 10001111b
      #   granularity=1 32-bit-default=0 64-bit seg=0 AVL=0
00    #

#7E28 [+20]
#:GDT_data16:
FF FF # limit 0:15
00 00 # base  0:15
00    # base 16:23
92    # access byte 10010010b 
      #   present=1 privilege=00 type=1
      #   code=0 conforming=0 readable=1 accessed=0
8F    # flags, limit 16:19 10001111b  
      #   granularity=1 32-bit-default=0 64-bit seg=0 AVL=0
00    # base 24:31

#7E30
#:GDT_locator
27 00        #  length
08 7E 00 00  #  GDT_start


# ------------------------------------------------------------
# Kernel Functions
# ------------------------------------------------------------

#----------------------------------------
#[7E36][3D]
#:start_32bit_main()
B8 01 24              # mov ax,2401h     # enable A20 line
CD 15                 # int 15h

FA                    # cli
0F 01 16 30 7E        # lgdt GDT_locator
0F 20 C0              # mov eax, cr0
66 83 C8 01           # or eax, 0x01
0F 22 C0              # mov cr0, eax
EA 50 7E 08 00        # JMP jmp setup_32bit
#[7E50][@1A][23]
#:setup_32bit
66 B8 10 00           # mov ax, 0x0010      ; data descriptor
8E D8                 # mov ds, ax
8E D0                 # mov ss, ax
8E C0                 # mov es, ax
8E E0                 # mov fs, ax
8E E8                 # mov gs, ax
BD 0F FF 1F 00        # mov ebp, 0x1FFFF0
89 EC                 # mov esp, ebp

9A 73 7E 00 00 08 00  # call setup_interrupt_handlers
9A 1A 85 00 00 08 00  # call app_main


#----------------------------------------
#[7E73][40]
#:setup_interrupt_handlers
53                    # push ebx

# handle the timer interrupt 08
BB 40 00 01 00        # mov ebx, &interrupt_table[08]
66 C7 03 B9 7E        # mov word [ebx + 0], low_address stub_interrupt_handler
66 C7 43 06 00 00     # mov word [ebx + 6], high_address
66 C7 43 02 08 00     # mov word [ebx + 2], code_segment = 0x0800
C6 43 05 8E           # mov byte [ebx + 5], flags = 8E

# handle int 80
BB 00 04 01 00        # mov ebx, &interrupt_table[80]
66 C7 03 C6 7F        # mov word [ebx + 0], low_address syscall_interrupt_handler
66 C7 43 06 00 00     # mov word [ebx + 6], high_address
66 C7 43 02 08 00     # mov word [ebx + 2], code_segment = 0x0800
C6 43 05 8E           # mov byte [ebx + 5], flags = 8E

# load the interrupt table
FA                    # cli
0F 01 1D B3 7E 00 00  # lidt [0x00007EB3] IDT_locator_32
FB                    # sti
5B                    # pop ebx
CB                    # retf


#----------------------------------------
#[7EB3][06]
#:IDT_locator_32
FF 07        #  length
00 00 01 00  #  IDT_start


#----------------------------------------
#stub_interrupt_handler
#[7EB9]
CF                    # iret


#------------------------------------------------------------
# 32 -> 16 -> 32 bit switching functions
#------------------------------------------------------------
# When switching between real mode and
# protected, registers are stored here:
#
# 7B14  edx
# 7B10
# 7B0C
# 7B08  eax
# 7B04  esp
#
# 7B00  <- top of real mode stack


#----------------------------------------
#[7EBA][61]
#:enter_16bit_real
FA                    # cli
A3 08 7B 00 00        # mov [0x7B08], eax  ; preserve so we can use these locally
89 15 14 7B 00 00     # mov [0x7B14], edx  ;
5A                    # pop edx            ; capture return address
89 25 04 7B 00 00     # mov [0x7B04], esp  ; capture stack

# The following far jump sets CS to a 16-bit protected mode selector
# and the segment registers are also set to 16-bit protected mode selectors.
# This is done prior to entering real mode.
EA D4 7E 00 00 18 00  # jmp 0x18:setup_16bit
#[7ED4]
#:setup_16bit
B8 20 00              # mov eax, 0x0020
8E D0                 # mov ss, eax
8E D8                 # mov ds, eax
8E C0                 # mov es, eax
8E E8                 # mov gs, eax
8E E0                 # mov fs, eax
BC 00 7B              # mov sp, 0x7B00
0F 20 C0              # mov eax, cr0
66 83 E0 FE           # and eax, 0xfffffffe  ; clear protected mode
0F 22 C0              # mov cr0, eax
# The following far jump sets CS to a 16-bit real mode segment
# and the segment registers are also set to real mode segments.
EA F3 7E 00 00        # jmp 0000:XXXX  real_mode
#[7EF3]
#:real_mode
B8 00 00              # mov ax, 0x0
8E D8                 # mov ds, ax
8E E0                 # mov fs, ax
8E E8                 # mov gs, ax
8E D0                 # mov ss, ax
8E C0                 # mov es, ax
BC 00 7B              # mov sp, 0x7B00
FA                    # cli
0F 01 1E 15 7F        # lidt IDT
FB                    # sti
# Using retf to set CS comes from here:
# https://stackoverflow.com/questions/26448480/bios-interrupts-in-protected-mode
# This page recommends a far jump followed by sti:
# https://www.sudleyplace.com/pmtorm.html
6A 00                 # push 0x0000 (2 bytes!)  CS to return to
52                    # push dx  IP to return to
A1 08 7B              # mov ax, [0x7B08]  ; restore from above
8B 16 14 7b           # mov dx, [0x7B14]
CB                    # retf

# IDT
#[7F15]
FF FF
00 00 00 00


#----------------------------------------
#[7F1B][40]
#:resume_32bit_mode()
# modifies: ebp and all segment registers
FA                    # cli
A3 08 7B              # mov [0x7B08], ax  ; preserve, they might be return values from 16 bit
89 16 14 7b           # mov [0x7B14], dx
5A                    # pop dx      ; carry the return IP in dx
58                    # pop ax      ; CS
0F 01 16 30 7E        # lgdt GDT_locator
0F 20 C0              # mov eax, cr0
66 83 C8 01           # or eax, 0x01         ; enable protected mode
0F 22 C0              # mov cr0, eax
EA 39 7F 08 00        # JMP restore_32bit
#[7F39]
#:restore_32bit
B8 10 00 00 00        # mov eax, 0x0010      ; data descriptor
8E D8                 # mov ds, eax
8E D0                 # mov ss, eax
8E C0                 # mov es, eax
8E E0                 # mov fs, eax
8E E8                 # mov gs, eax
8B 25 04 7B 00 00     # mov esp, [0x7B04]   ; restore, (saved in enter_16bit_mode)
9A 73 7E 00 00 08 00  # call setup_interrupt_handlers
52                    # push edx            ; setup our return location
# These restore the 16 bit portion of these registers, which may be a
# return value from a 16 bit function, and they also restore any previous high
# bits that were stored by enter_16bit_mode so these registers need not be
# saved when going to 16 bit mode and back if you want them left alone.
A1 08 7B 00 00        # mov eax, [0x7B08]   ; restore, (saved at top of this function)
8B 15 14 7B 00 00     # mov edx, [0x7B14]
C3                    # ret


# ------------------------
#[7F62][10]
#:console_putc:
#
E8 53 FF FF FF  # CALL enter_16bit_real, next=[7F67]
9A 5F 7C 00 00  # CALL console_putc_16(al)
9A 1B 7F 00 00  # CALL resume_32bit_mode
CB              # RETF


# ------------------------
#:console_put_hex
#[7F72][10]
E8 43 FF FF FF  # CALL enter_16bit_real, next=[7F77]
9A 75 7C 00 00  # CALL console_put_hex_16(al)
9A 1B 7F 00 00  # CALL resume_32bit_mode
CB              # RETF


# ------------------------
#[7F82][1A]
#:console_puts (ds:si = string)
#:puts_loop
50                    # push eax
8A 06                 # mov al, [esi]
3C 00                 # cmp al, 0
74 0A                 # jz end_loop
9A 62 7F 00 00 08 00  # call console_putc
46                    # inc esi
EB F0                 # jmp puts_loop
#:end_loop
B0 0A                 # mov al, 0A
9A 62 7F 00 00 08 00  # call console_putc
58                    # pop eax
CB                    # RETF


#[7F9E][18]
# ------------------------
#:get_partition_start(eax=partition_num 1..4)
#returns:
# cx = cylinder/sector
# dh = head
#
50              # PUSH_EAX
56              # PUSH_ESI

6B C0 10        # imul eax, 0x10
89 c6           # mov esi, eax         ; esi = entry_offset
BB AE 7D 00 00  # mov ebx, 7DAE        ; ebx = &partition_table[-1]
8A 74 33 01     # mov dh, [ebx+esi+1]  ; dh = head = partition_table[al][0]
66 8B 4C 33 02  # mov cx, [ebx+esi+2]  ; cx = cyl/sector = partition_table[al][1]

5E              # POP_ESI
58              # POP_EAX
CB              # retf


# ------------------------
#[7FB6][10]
#:read_sectors(di = *dest_addr, cx=cylinder/sector, dh = head, ax=num_sectors)
E8 FF FE FF FF  # CALL enter_16bit_real, next=[7FBB]
9A 1F 7D 00 00  # CALL read_sectors_16
9A 1B 7F 00 00  # CALL resume_32bit_mode
CB              # RETF


# ------------------------
#[7FC6][29]
#:syscall_interrupt_handler
83 F8 01              # cmp eax, 1
75 08                 # jne try next
9A 99 99 00 00 08 00  # call handle_syscall_exit
CF                    # iret

83 F8 02              # cmp eax, 2
75 08                 # jne try next
9A 99 99 00 00 08 00  # call handle_syscall_fork
CF                    # iret

83 F8 03              # cmp eax, 3
75 08                 # jne try next
9A 16 81 00 00 08 00  # call handle_syscall_read
CF                    # iret

83 F8 04              # cmp eax, 4
75 08                 # jne try next
9A C0 81 00 00 08 00  # call handle_syscall_write
CF                    # iret

83 F8 05              # cmp eax, 5
75 08                 # jne try next
9A 3E 80 00 00 08 00  # call handle_syscall_open
CF                    # iret

83 F8 07              # cmp eax, 7
75 08                 # jne try next
9A 99 99 00 00 08 00  # call handle_syscall_waitpid
CF                    # iret

83 F8 0B              # cmp eax, B
75 08                 # jne try next
9A 99 99 00 00 08 00  # call handle_syscall_execve
CF                    # iret

83 F8 2D              # cmp eax, 2D
75 08                 # jne try next
9A 99 99 00 00 08 00  # call handle_syscall_brk
CF                    # iret

#[802E][08]
#s  c  /  o  p  e  n \0
73 63 2F 6F 70 65 6E 00

#[8036][04]
# next fileno
04 00 00 00

#[803A][04]
# next file address
00 00 50 00

#------------------------------------------------------------
#[803E][20]
#:handle_syscall_open(ebx=filename, ecx=flags)
56                    # push esi
57                    # push edi
51                    # push ecx

BE 2E 80 00 00        # mov esi, "sc/open"
9A 82 7F 00 00 08 00  # call console_puts

90 90 90 90 90 90 90
90 90 90 90 90 90 90

89 DE                 # mov esi, ebx
9A 82 7F 00 00 08 00  # call console_puts

F7 C1 01 00 00 00     # test ecx, 1
74 51                 # jz open_read

# copy filename to new slot
89 DE                 # mov esi, ebx
BF 00 00 40 00        # mov edi, 0x0400000
A1 36 80 00 00        # mov eax, [&next_fileno]
C1 E0 0A              # shl eax, 0a
01 C7                 # add edi, eax
B9 00 04 00 00        # mov ecx, 0x0000400
F3 A4                 # rep movsb

# set address of file
BF 00 00 30 00        # mov edi, 0x0300000
A1 36 80 00 00        # mov eax, [&next_fileno]
C1 E0 02              # shl eax, 02
01 C7                 # add edi, eax
8B 0D 3A 80 00 00     # mov ecx, [0x803A]
C7 01 00 00 00 00     # mov long [ecx], 0
41                    # inc ecx
89 0D 3A 80 00 00     # mov [0x803A], ecx
89 0F                 # mov [edi], ecx

A1 36 80 00 00        # mov eax, [next_fileno]
40                    # inc eax
A3 36 80 00 00        # mov [next_fileno], eax
48                    # dec eax
9A 72 7F 00 00 08 00  # call console_put_hex
EB 4F                 # jmp finish

#open_read
#find file
BA 04 00 00 00        # mov edx, 4
#check file
89 DE                 # mov esi, ebx
BF 00 00 40 00        # mov edi, 0x0400000
89 D0                 # mov eax, edx
C1 E0 0A              # shl eax, 0a
01 C7                 # add edi, eax

90 90 90 90 90 90 90 90 90

B9 00 04 00 00        # mov ecx, 0x0000400
F3 A6                 # rep cmpsb
74 11                 # je match

# if not on last file, continue checking
42                    # inc edx
A1 36 80 00 00        # mov eax, [next_fileno]
39 C2                 # cmp edx, eax
75 D6                 # jne checkfile

#no match
B8 FF FF FF FF        # mov eax, 0xffffffff
EB 19                 # jmp finish

#match
89 D0                 # mov eax, edx

# set read offset to start of file
BE 00 08 01 00        # mov esi, 0x0010804
C1 E2 03              # shl edx, 03
01 D6                 # add esi, edx
31 D2                 # xor edx, edx
89 16                 # mov [esi], edx       ; mov edx, current offset

90 90 90 90
90 90 90 90
90

# finish
59                    # pop ecx
5F                    # pop edi
5E                    # pop esi
CB                    # ret

90 90 90 90 90 90

#------------------------------------------------------------
#[8116][70]
#:handle_syscall_read(ecx=*return_char, ebx=file)
50                    # push eax
53                    # push ebx
51                    # push ecx
52                    # push edx
56                    # push esi
57                    # push edi

51                    # push ecx   ; we need this later to return char
83 FB 00              # cmp ebx, 0
75 65                 # jne memfile

# stdin is /dev/hda4
# get current position
66 8B 0D 00 08 01 00  # mov cx, [0x10800]  ; cyl/sector
8A 35 02 08 01 00     # mov dh, [0x10802]  ; head
31 C0                 # xor eax, eax
66 A1 04 08 01 00     # mov ax, [0x10804]  ; offset
#end of sector?
66 3D ff 01           # cmp ax, 0x01ff
74 04                 # je next sector

#nextchar:
66 40                 # inc ax
EB 2A                 # jmp getchar

#read next sector
BF 00 A0 00 00        # mov edi, 0x000A000
B8 01 00 00 00        # mov eax, 0x0001   ; num_sectors = 1
9A B6 7F 00 00 08 00  # call read_sectors

# save new location and offset
66 89 0D 00 08 01 00  # mov [0x10800], cx
88 35 02 08 01 00     # mov [0x10802], dh
31 C0                 # xor eax, eax

# move block to device buffer
BE 00 A0 00 00        # mov esi, 0x000A000
BF 00 00 02 00        # mov edi, 0x0020000
B9 00 02 00 00        # mov ecx, 0x0000200
F3 A4                 # rep movsb

#getchar:
66 A3 04 08 01 00     # mov [0x10804], ax
59                    # pop ecx
BB 00 00 02 00        # mov ebx, 0x20000    ; device buffer
89 C6                 # mov esi, eax        ; offset
8A 04 33              # mov al, [ebx+esi+0]
88 01                 # mov [ecx], al
EB 2D                 # jmp finish

#memfile:

# get file address
BE 00 00 30 00        # mov esi, 0x0300000   ; pfile_addr = &file_address[0]
89 D9                 # mov ecx, ebx
C1 E1 02              # shl ecx, 02
01 CE                 # add esi, ecx         ; pfile_addr += sizeof(file_address) * fileno
8B 0E                 # mov ecx, [esi]       ; mov ecx, [&fileaddr]
# get current read offset from descriptor
BE 00 08 01 00        # mov esi, 0x0010804   ; pcurrent_offset = &file_descriptor[0].address
89 DA                 # mov edx, ebx
C1 E2 03              # shl edx, 03
01 D6                 # add esi, edx         ; pcurrent_offset += sizeof(descriptor) * fileno
8B 16                 # mov edx, [esi]       ; mov edx, current offset
FF 06                 # inc long [esi]       ; *pcurrent_offset++

90 90 90 90
90 90 90 90 90

8A 04 11              # mov al, [ecx+edx]
59                    # pop ecx
88 01                 # mov [ecx], al

90 90 90 90 90

#finish:
5F                    # pop edi
5E                    # pop esi
5A                    # pop edx
59                    # pop ecx
5B                    # pop ebx
58                    # pop eax
CB                    # ret


#------------------------------------------------------------
#:handle_syscall_brk


#------------------------------------------------------------
#[81C0]
#:handle_syscall_write(ebx=file,ecx=*char_to_write)
50                    # push eax
51                    # push ecx
52                    # push edx
56                    # push esi

# get char to write
8A 01                 # mov al, [ecx]

90 90 90 90
90 90 90 90
90 90 90 90
90 90

# stdout?
83 FB 01              # cmp ebx, 01
75 09                 # jnz memfile

# stdout -> console_out
9A 62 7F 00 00 08 00  # call console_putc
EB 36                 # jmp finish

#memfile
#ebx=filenum
# get file address
BE 00 00 30 00        # mov esi, 0x0300000
89 D9                 # mov ecx, ebx
C1 E1 02              # shl ecx, 02
01 CE                 # add esi, ecx
8B 0E                 # mov ecx, [esi]       ; mov ecx, [&fileaddr]
# get current write offset from descriptor
BE 00 08 01 00        # mov esi, 0x0010804
89 DA                 # mov edx, ebx
C1 E2 03              # shl edx, 03
01 D6                 # add esi, edx
8B 16                 # mov edx, [esi]       ; mov edx, current offset
FF 06                 # inc long [esi]       ; current_offset++

01 D1                 # add ecx, edx
88 01                 # mov [ecx], al

90 90 90 90
90 90 90

89 0D 3A 80 00 00     # mov ecx, [0x803A]
41                    # inc ecx              ; *next_file_addr++
89 0D 3A 80 00 00     # mov [0x803A], ecx

#finish
5E                    # pop esi
5A                    # pop edx
59                    # pop ecx
58                    # pop eax
CB                    # ret


#:handle_syscall_fork
#:handle_syscall_execve
#[821D]
#s  c  /  e  x  e  c
73 63 2F 65 78 65 63 00

#:handle_syscall_waitpid
#:handle_syscall_exit


#:create_file
#:create_process
#:relocate_process

#------------------------------------------------------------
# The Standard Library
#------------------------------------------------------------
#:open_read
#:open_write


# ----------------------------------------
# variables for read
#
#[8225]  char io_char
00
00  # free

#[8227][26]
#:read
53                    # push ebx
51                    # push ecx
52                    # push edx
B8 03 00 00 00        # mov eax, 3   ; syscall=read
B9 25 82 00 00        # mov ecx, &io_char
BA 01 00 00 00        # mov edx, 1   1 byte characters

CD 80                 # int 80 syscall
85 C0                 # test eax, eax
74 05                 # je error_exit

A0 25 82 00 00        # mov al, &io_char
5A                    # pop edx
59                    # pop ecx
5B                    # pop ebx
CB                    # ret

#:brk
90 90 90 90 90


#[824D][26]
#:write
50                    # push eax
53                    # push ebx
51                    # push ecx
52                    # push edx

A2 25 82 00 00        # mov &io_char, al
B8 04 00 00 00        # mov eax, 4   ; syscall=write
B9 25 82 00 00        # mov ecx, &io_char
BA 01 00 00 00        # mov edx, 1   1 byte characters
CD 80                 # int 80 syscall

5A                    # pop edx
59                    # pop ecx
5B                    # pop ebx
58                    # pop eax
CB                    # ret


#:fork
90 90 90 90 90 90 90


#:execve


#:exit

# ------------------------------------------------------------
# Utilities
# ------------------------------------------------------------

#[8273][0F]
#read_line(ebx=file, edi=linemem)
50                    # push eax
9A 27 82 00 00 08 00  # call read
AA                    # stosb
3C 0A                 # cmp al, '\n'
75 F4                 # jne read_line
58                    # pop eax
CB                    # ret


#[8282][0F]
#write_line(ebx=file, esi=linemem)
50                    # push eax
#write_char
AC                    # lodsb
9A 4D 82 00 00 08 00  # call write
3C 0A                 # cmp al, '\n'
75 F4                 # jne write_char

58                    # pop eax
CB                    # ret


#[8291][04]
#s  r  c \0
73 72 63 00

#----------------------------------------
# src: create file from stdin
#
# Read an integer, N, in decimal from stdin.
# Read a space.
# Then, read a file name to create.
# Read a newline.
# Then, read N lines from stdin and write to the new file.
#[8295]
#:src
50                    # push eax
53                    # push ebx
51                    # push ecx
52                    # push edx
56                    # push esi
57                    # push edi

31 C9                 # xor ecx, ecx        ; line count=0

90 90

BE 91 82 00 00        # mov esi,  "src"
9A 82 7F 00 00 08 00  # call console_puts

9A 27 82 00 00 08 00  # call read 'r'
9A 27 82 00 00 08 00  # call read 'c'
9A 27 82 00 00 08 00  # call read ' '

#parse_line_count_loop:
9A 27 82 00 00 08 00  # call read
3C 20                 # cmp al, ' '
74 0C                 # je got count

6B C9 0A              # imul ecx, ecx, 10   ; count = count * 10
2C 30                 # sub al, 30
0F B6 C0              # movzx eax, al
01 C1                 # add ecx, eax        ; count += digit

EB E9                 # jmp parse_line_count_loop

# got_count:
88 E8                 # mov al, ch
9A 72 7F 00 00 08 00  # call put_hex
88 C8                 # mov al, cl
9A 72 7F 00 00 08 00  # call put_hex

# clear arguments
51                    # push ecx
31 C0                 # xor eax, eax
BA 00 00 20 00        # mov edx, 0x00200000
B9 00 08 00 00        # mov ecx, 0x00000800
90
#zeroloop
88 02                 # mov [edx], al
42                    # inc edx
49                    # dec ecx
75 FA                 # jnz zeroloop
59                    # pop ecx

90 90 90 90
90 90 90 90
90 90 90 90
90 90 90 90
90 90 90 90
90 90 90 90
90 90

51                    # push ecx
B9 00 00 20 00        # mov ecx, 0x00200000
# get_filename_loop:
9A 27 82 00 00 08 00  # call read

90 90 90 90 90 90 90
90 90

3C 0A                 # cmp al, '\n'
74 05                 # je got_filename
88 01                 # mov [ecx], al
41                    # inc ecx
EB E7                 # jmp get_file_name_loop
59                    # pop ecx

# got_filename:
BE 00 00 20 00        # mov esi, 0x00200000
9A 82 7F 00 00 08 00  # call console_puts

# open filename for write
51                    # push ecx
BB 00 00 20 00        # mov ebx, 0x00200000
B8 05 00 00 00        # mov eax, 5  ; syscall_open
B9 41 02 00 00        # mov ecx, 0x00000241 O_TRUNC (0x200) | O_CREAT (0x40) | O_WRONLY (0x1)
BA 80 01 00 00        # mov edx, 0x00000180 S_IRUSR (0x100) | S_IWUSR (0x80)
CD 80                 # int 80
59                    # pop ecx

# eax has the open file number

# readwrite_loop:
BF 00 00 38 00        # mov edi, 0x00380000   ; io buffer
31 DB                 # xor ebx, ebx   ; ebx=0=stdin
9A 73 82 00 00 08 00  # call read_line
89 C3                 # mov ebx, eax          # prepare to write
BE 00 00 38 00        # mov esi, 0x00380000
9A 82 82 00 00 08 00  # call write_line
49                    # dec ecx   ; count--
75 E1                 # jnz read_write_loop

5F                    # pop edi
5E                    # pop esi
5A                    # pop edx
59                    # pop ecx
5B                    # pop ebx
58                    # pop eax
CB                    # ret

#[8382][05]
#h  e  x  0 \0
68 65 78 30 00

#------------------------------------------------------------
#:hex0
#[8387]
53                    # push ebx
56                    # push esi
57                    # push edi

BE 82 83 00 00        # mov esi,  "hex0"
9A 82 7F 00 00 08 00  # call console_puts
9A 27 82 00 00 08 00  # call read 'e'
9A 27 82 00 00 08 00  # call read 'x'
9A 27 82 00 00 08 00  # call read '0'
9A 27 82 00 00 08 00  # call read ' '

# clear arguments
31 C0                 # xor eax, eax
BA 00 00 20 00        # mov edx, 0x00200000
B9 00 08 00 00        # mov ecx, 0x00000800
#zeroloop
88 02                 # mov [edx], al
42                    # inc edx
49                    # dec ecx
75 FA                 # jnz zeroloop

90 90 90 90
90 90 90 90
90 90 90

BA 00 00 20 00        # mov edx, 0x00200000
#get_file_name1_loop
9A 27 82 00 00 08 00  # call read
3C 20                 # cmp al, ' '
74 05                 # je got_filename1
88 02                 # mov [edx], al
42                    # inc edx
EB F0                 # jmp get_file_name_loop

#got_filename1
BA 00 04 20 00        # mov edx, 0x00200400
#get_file_name2_loop
9A 27 82 00 00 08 00  # call read
3C 0A                 # cmp al, '\n'
74 05                 # je got_filename2
88 02                 # mov [edx], al
42                    # inc edx
EB F0                 # jmp get_file_name_loop

50
B0 90
9A 72 7F 00 00 08 00  # call put_hex
58

# open filename1 for read
BB 00 00 20 00        # mov ebx, 0x00200000
B8 05 00 00 00        # mov eax, 5  ; syscall_open
B9 00 00 00 00        # mov ecx, 0x00000000
CD 80                 # int 80

50                    # push eax  ; save read fileno

90 90 90 90 90 90 90 90

# open filename2 for write
BB 00 04 20 00        # mov ebx, 0x00200400
B8 05 00 00 00        # mov eax, 5  ; syscall_open
B9 41 02 00 00        # mov ecx, 0x00000241 O_TRUNC (0x200) | O_CREAT (0x40) | O_WRONLY (0x1)
BA 80 01 00 00        # mov edx, 0x00000180 S_IRUSR (0x100) | S_IWUSR (0x80)
CD 80                 # int 80
89 C2                 # mov edx, eax

90 90 90 90 90 90 90

59                    # pop ecx                 ; restore read fileno

# this flag is set after the first digit is seen
31 DB                 # xor ebx, ebx

90 90 90 90
90 90 90 90
90

#[8442]
#:read_loop
53                    # push ebx
89 CB                 # mov ebx, ecx
9A 27 82 00 00 08 00  # call read
5B                    # pop ebx


90 90 90 90
90 90 90 90
90 90 90

84 C0                 # test al, al
75 04                 # jnz check_command
5F                    # POP_DI
5E                    # POP_SI
5B                    # POP_BX
CB                    # RETF

#:check_command
3C 23                 # cmp al, '#'
74 28                 # jz skip_comment

3C 3B                 # cmp ';'
74 24                 # jz skip_comment

3C 66                 # cmp al, 'f'
7F CF                 # jg read_loop

3C 61                 # cmp al, 'a'
7C 04                 # jl maybe_upper

# Handle a to f
2C 57                 # sub al, 'a'-10 == 87 = 0x57
EB 30                 # jmp maybe_store

#:maybe_upper
3C 46                 # cmp al, 'F'
7F C3                 # jg read_loop

3C 41                 # cmp al, 'A'
7C 04                 # jl maybe_digit

# Handle A to F
2C 37                 # sub al, 'A'-10 == 55 = x37
EB 24                 # jmp maybe_store

#:maybe_digit
3C 39                 # cmp al, '9'
7F B7                 # jg read_loop

3C 30                 # cmp al, '0'
7C B3                 # jl read_loop

# Handle 0 to 9
2C 30                 # sub al, '0' == x30
EB 18                 # jmp maybe_store

#:skip_comment
53                    # push ebx
89 CB                 # mov ebx, ecx
9A 27 82 00 00 08 00  # call read
90 90 90 90 90 90 90
5B                    # pop ebx
3C 0A                 # cmp al, '\n'
75 EA                 # jnz skip_comment
EB 97                 # jmp read_loop

# only store on second digit
#:maybe_store
84 DB                 # test bl, bl
75 09                 # jnz second_digit

# If on first digit, record and keep going
#:first_digit
C0 E0 04              # shl al, 4
88 C7                 # mov bh, al
FE C3                 # inc bl
EB 8A                 # jmp read_loop

# If on second digit, store and clear state
#:second_digit
08 C7                 # or bh, al
88 F8                 # mov al, bh

9A 72 7F 00 00 08 00  # call put_hex
52 # push edx
53                    # push ebx
89 D3                 # mov ebx, edx
9A 4D 82 00 00 08 00  # call write
5B                    # pop ebx
5A # pop edx

90 90 90 90
90 90 90 90
90 90 90

31 DB                 # xor bx, bx

EA 42 84 00 00 08 00                 # jmp read_loop
#EB 69

#:end_read_loop
5F                    # POP_DI
5E                    # POP_SI
5B                    # POP_BX

CB                    # RETF

90 90 90 90
90 90 90 90
90 90 90 90

#:handle_other_command
#[84F4]
BE 1D 82 00 00        # mov esi, "sc/exec"
9A 82 7F 00 00 08 00  # call console_puts

9A 62 7F 00 00 08 00  # call console_putc
9A 27 82 00 00 08 00  # call read
3C 0A                 # cmp al, '\n'
75 EE                 # jne gather_other_command
9A 62 7F 00 00 08 00  # call console_putc
CB


#[851A]
# ------------------------------------------------------------
# Main Program Body
# ------------------------------------------------------------
#:app_main (dl=boot_drive)
# Set up /dev/hda4 as global stdin
B8 04 00 00 00        # mov eax, 4
9A 9E 7F 00 00 08 00  # call get_partition_start(4)

# save disk location and byte offset to descriptor
66 89 0D 00 08 01 00  # mov [0x10800], cx
88 35 02 08 01 00     # mov [0x10802], dh
# start at "end of sector" to trigger an initial sector read
66 B9 FF 01           # mov cx, 0x01FF
66 89 0D 04 08 01 00  # mov [0x10804], cx

# read from stdin
31 DB                 # xor ebx, ebx

#:process_command:
9A 27 82 00 00 08 00  # call read
3C 00                 # cmp al, 0           ; check_end
74 23                 # je finish_success

#check_src_command
3C 73                 # cmp al, 's'
75 09                 # jne check_hex0

#handle_src_command
9A 95 82 00 00 08 00  # call src
EB E8                 # jmp process_command

#check_hex0_command
3C 68                 # cmp al, 'h'
75 09                 # jne handle_other_command

#handle_hex0_command
9A 87 83 00 00 08 00  # call hex0
EB DB                 # jmp process_command

#handle_other_command:
#gather_other_command:
9A F4 84 00 00 08 00  # call handle_other_command
EB D2                 # jmp process_command

#finish_success
#zero source
#call reboot
#:error_exit
BE 16 7C 00 00        # mov esi, "Halting..."
9A 82 7F 00 00 08 00  # call console_puts

# one space to flush last line
B0 20                 # mov al, 20
9A 62 7F 00 00 08 00  # call console_putc

FA F4

# END Program Body


00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
#[85C0]
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
