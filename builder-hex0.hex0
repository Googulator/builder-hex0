# Builder-Hex0
#
# Builder-Hex0 is a small bootable machine image which has
# the ability to compile hex0 code. It is also written in hex0
# and so it can build itself if provided with its own source code.
#
# hex0 is a "language" for binary encoding in hexadecimal
# with support for comments.


# ------------------------------------------------------------
# Stub Entry Point
#
# boot drive is in dl
#
#[7D00][10]
#:_start

# We cannot be sure the registers are initialized to zero so we
# do that first. We far jump to main in order to set CS.
31 C0           # xor ax, ax
8E D8           # COPY_AX_to_DS
8E C0           # COPY_AX_to_ES
8E D0           # COPY_AX_to_SS
BC 00 7C        # mov sp, 0x7C00
EA FD 7C 00 00  # JMP 00007CFD  jmp main


# ------------------------------------------------------------
# Global Data
#[7C10][0D]
#H  a  l  t  i  n  g  .  .  . \r \n \0
48 61 6C 74 69 6E 67 2E 2E 2E 0D 0A 00

#[7C1D][0F]
#R  e  b  o  o  t  i  n  g  .  .  . \r \n \0
52 65 62 6F 6F 74 69 6E 67 2E 2E 2E 0D 0A 00

#[7C2C][13]
#N  o     S  o  u  r  c  e    f   o  u  n  d  . \r \n \0
4E 6F 20 73 6F 75 72 63 65 20 66 6F 75 6E 64 2E 0D 0A 00

#[7C3F][12]
#B  u  i  l  d     f  i  n  i  s  h  e  d  . \r \n \0
42 75 69 6C 64 20 66 69 6E 69 73 68 65 64 2E 0D 0A 00


# ------------------------------------------------------------
# Standard Library functions
# ------------------------------------------------------------

# ------------------------
#[7C51]
#:halt
F4      # hlt
EB FD   # jmp halt

# ------------------------
#[7C54]
#:reboot
EA F0 FF 00 F0  # ljmp $F000:FFF0

# ------------------------
#[7C59][0C]
#:putc (al=c)
53        # PUSH_BX
50        # PUSH_AX

# Prepare to use BIOS tty output interrupt.
# Specify text page 00, 0 black background, 7 light grey text
BB 00 07  # LOADI16_BX 0007
# Specify the `write character` BIOS routine
B4 0E     # LOADI8_AH  0E
CD 10     # INT_10

58        # POP_AX
5B        # POP_BX
CB        # RETF

# ------------------------
#[7C65][0D]
#:puts (ds:si = string)
#:puts_loop
AC              # lodsb  al=[ds:si++]
84 C0           # test al, al
74 07           # jz end_loop
9A 59 7C 00 00  # CALL 00007C59  call putc
EB F4           # jmp puts_loop
#:end_loop
CB              # RETF

# ------------------------

#[7C72][1A]
#:read_source()
50        # PUSH_AX
53        # PUSH_BX
51        # PUSH_CX

#:read_loop
BB 00 AA  # LOADI16_BX AA00  ; destination address for read = ES:BX = 0000:AA00
B8 14 02  # LOADI16_AX 0214  ; rw mode = 02 (read),  num_sectors = 0x14
B9 16 00  # LOADI16_CX 0016  ; cylinder = 0, sector_num = 0x16
B6 00     # LOADI8_DH 00     ; head = 0
CD 13     # INT_13
72 F1     # jnc read_loop
3C 14     # cmp al, 0x14
75 ED     # jnz read_loop

59        # POP_CX
5B        # POP_BX
58        # POP_AX
CB        # RETF

#[7C8C][14]
#:write_image()
50        # PUSH_AX
53        # PUSH_BX
51        # PUSH_CX

BB 00 80  # LOADI16_BX 8000  ; source address for write = ES:BX = 0000:8000
B8 16 03  # LOADI16_AX 0201  ; rw mode = 03 (write),  num_sectors = 0x16
B9 01 00  # LOADI16_CX 0001  ; cylinder = 0, sector_num = 01
B6 00     # LOADI8_DH 00     ; head = 0
CD 13     # INT_13

59        # POP_CX
5B        # POP_BX
58        # POP_AX
CB        # RETF


#[7CA0][5F]
# ----------------------------------------
# Compile hex0 to binary
#compile():
53              # PUSH_BX
56              # PUSH_SI
57              # PUSH_DI

# this flag is set after the first digit is seen
31 DB           # xor bx,bx

# Start processing the source blocks
BE 00 AA        # mov si, 0xAA00
BF 00 80        # mov di, 0x8000

#:read_loop
AC              # lodsb

#[0c]
84 C0           # test al, al
74 49           # jz end_read_loop

3C 23           # cmp al, '#'
74 28           # jz skip_comment

3C 3B           # cmp ';'
74 24           # jz skip_comment

3C 66           # cmp al, 'f'
7F EF           # jg read_loop

3C 61           # cmp al, 'a'
7C 04           # jl maybe_upper

#[20]
# Handle a to f
2C 57           # sub al, 'a'-10 == 87 = 0x57
EB 1F           # jmp maybe_store

#:maybe_upper
3C 46           # cmp al, 'F'
7F E3           # jg read_loop

3C 41           # cmp al, 'A'
7C 04           # jl maybe_digit

# Handle A to F
2C 37           # sub al, 'A'-10 == 55 = x37
EB 13           # jmp maybe_store

#[30]
#:maybe_digit
3C 39           # cmp al, '9'
7F D7           # jg read_loop

3C 30           # cmp al, '0'
7C D3           # jl read_loop

# Handle 0 to 9
2C 30           # sub al, '0' == x30
EB 07           # jmp maybe_store

#[3e]
#:skip_comment
AC              # lodsb
3C 0A           # cmp al, '\n'
75 FB           # jnz skip_comment
EB C8           # jmp read_loop

#[45]
# only store on second digit
#:maybe_store
84 DB           # test bl, bl
75 09           # jnz second_digit

#[49]
# If on first digit, record and keep going
#:first_digit
C0 E0 04        # shl al, 4
88 C7           # mov bh, al
FE C3           # inc bl
EB BB           # jmp read_loop

#[52]
# If on second digit, store and clear state
#:second_digit
08 C7           # or bh, al
88 F8           # mov al, bh
AA              # stosb
31 DB           # xor bx, bx

EB B2           # jmp read_loop

#[5B]
#:end_read_loop
5F              # POP_DI
5E              # POP_SI
5B              # POP_BX
CB              # RETF

#[7CFD][45]
# ------------------------------------------------------------
# Main Program Body
#:main

# Load source code blocks
9A 72 7C 00 00  # CALL 00007C72  read_source()

# If there is no source jump down to the no_source handler
A0 00 AA         # mov AL, [AA00]
84 C0            # test al, al
74 2C            # jz no_source

9A A0 7C 00 00  # CALL 00007CA0  compile()

BE 3F 7C        # mov si, 0x7C3F si="Build finished."
9A 65 7C 00 00  # CALL 00007C65  puts(si)

# zero the source image
B0 00           # LOADI8_AL 00
A2 00 AA        # mov [AA00], AL

9A 8C 7C 00 00  # CALL 00007C8C  write_image()

# after a build occurs, invoke transition
BE 1D 7C        # mov si, 0x7C1D si="Rebooting..."
9A 65 7C 00 00  # CALL 00007C65  puts(si)
9A 54 7C 00 00  # CALL 00007C54  reboot()

# This code handles when there is no source code.
#:no_source
BE 2C 7C        # mov si, 0x7C2C si="No source found."
9A 65 7C 00 00  # CALL 00007C65  puts(si)

# we have no way to build now, so halt
BE 10 7C        # mov si, 0x7C10 si="Halting..."
9A 65 7C 00 00  # CALL 00007C65  puts(si)
9A 51 7C 00 00  # CALL 00007C51  halt()

# END Program Body

# ------------------------------------------------------------
# This is the rest of the MBR.

#[7D42]
      00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
#[7D80]
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00


# Partition entry 1
#[7DBE]
                                          00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00
# Partition entry 2
#[7DD0]
                                          00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00
# Partition entry 3
                                          00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00
# Partition entry 4
                                          00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00
#[7DFE]
# This is the DOS/MBR identifier at offset 510:
55 AA
