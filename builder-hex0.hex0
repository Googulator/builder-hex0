#
# Builder-Hex0 is a small bootable machine image which has
# the ability to compile hex0 code. It is also written in hex0
# and so it can build itself if provided with its own source code.
#
# hex0 is a "language" for binary encoding in hexadecimal
# with support for comments.

# --- stage 1
# _start
# [global data]
# halt
# reboot
#
# console_putc_16
# console_put_hex_16
# console_puts_16
#
# get_partition_start_16
# get_drive_geometry
# next_sector
# read_sectors_16
#
# mbr_main

# --- stage 2
# kern_main
# [GDT data]
# start_32bit_main
# setup_interrupt_handlers
# stub_interrupt_handler
# enter_16bit_real
# resume_32bit_mode
#
# console_putc
# console_put_hex
# console_puts
# get_partition_start
# read_sectors
#
# syscall_interrupt_handler
# handle_syscall_open
# handle_syscall_read
#
# --- "User Mode"
# app_main


#------------------------------------------------------------
# Memory:
# 800000 -        processes
# 500000 - 7FFFFF files 3M
# 401800 - 4FFC00 file names 6..1023
# 401400 - 4017FF file name 5
# 401000 - 4013FF file name 4
# 400010 - 400FF0 file lengths 4*1022
# 300000 - 3FFFFF io buffers/free
# 200800 - 2FFFFF cmd arg3..1024 (1022 args * 1K)
# 200400 - 2007FF cmd arg2 (1K)
# 200000 - 2003FF cmd arg1 (1K)
# 100000 - 1FFFF0 32 bit stack (1M)
#  9FC00 -  FFFFF BIOS
#  40000 -  9FBFF device buffers
#  20000 -  3FFFF process descriptors
#  10800 -  1FFFF opened file descriptors (16 bytes each)
#  10000 -  10800 interrupt table
#   A000 -   A1FF sector read buffer - 16bit
#   7C00 -   8600 code
#   7B00 -   7BFF Saved 32 bit registers while in 16 bit mode
# < 7B00          real mode stack
#------------------------------------------------------------


# ------------------------------------------------------------
# Stub Entry Point
#
# boot drive is in dl
#
#[7C00][13]
#:_start

# We cannot be sure the registers are initialized to zero so we
# do that first. We far jump to mbr_main in order to set CS.
31 C0           # xor ax, ax
8E D8           # COPY_AX_to_DS
8E C0           # COPY_AX_to_ES
FA              # cli               ;  cli/sti necessary on 8088
8E D0           # COPY_AX_to_SS
BC 00 7B        # mov sp, 0x7B00
FB              # sti
FC              # CLD ; clear direction flag

EA 48 7D 00 00  # jmp mbr_main


# ------------------------------------------------------------
# Global Data
#[7C13]
80     # boot_drive
0F     # boot drive max_head  0..15 
3F     # boot drive num_sectors / track (1..63)


#[7C16][0B]
#H  a  l  t  i  n  g  .  .  . \0
48 61 6C 74 69 6E 67 2E 2E 2E 00

#[7C21][0D]
#R  e  b  o  o  t  i  n  g  .  .  . \0
52 65 62 6F 6F 74 69 6E 67 2E 2E 2E 00

#[7C2E][11]
#N  o     s  o  u  r  c  e    f   o  u  n  d  . \0
4E 6F 20 73 6F 75 72 63 65 20 66 6F 75 6E 64 2E 00

#[7C3F][10]
#B  u  i  l  d     f  i  n  i  s  h  e  d  . \0
42 75 69 6C 64 20 66 69 6E 69 73 68 65 64 2E 00

#[7C4F][8]
# available
00 00 00 00 00 00 00 00


# ------------------------
#[7C57]
#:halt
#
F4      # hlt
EB FD   # jmp halt

# ------------------------
#[7C5A]
#:reboot
#
EA F0 FF 00 F0  # ljmp $F000:FFF0

# ------------------------
#[7C5F][16]
#:console_putc_16(al=c)
#
# Note: with QEMU+Seabios this does not flush the last character or
# CRLF of a line until the first character is output on the next line
# and that character cannot be another CRLF.
53        # PUSH_BX
50        # PUSH_AX

# Prepare to use BIOS tty output interrupt.
# Specify text page 00, 0 black background, 7 light grey text
BB 00 07  # LOADI16_BX 0007
# Specify the `write character` BIOS routine
B4 0E     # LOADI8_AH  0E

3C 0A     # cmp al, 0A
75 06     # jne regular

# convert LF to CR LF for BIOS output
B0 0D     # mov al, 0D
CD 10     # INT_10
B0 0A     # mov al, 0A

#:regular:
CD 10     # INT_10

58        # POP_AX
5B        # POP_BX
CB        # RETF

#[7C75][31]
#:console_put_hex_16(al=byte)
50              # PUSH_AX

24 F0           # and al, 0xF0
C0 E8 04        # shr al, 4
3C 09           # cmp al, 9
7F 04           # jg alpha
#10

#numeral:
04 30           # add al, 0x30
EB 02           # jmp print1

#alpha:
04 37           # add al, 0x37
#16

#print1:
9A 5F 7C 00 00  # CALL 00007C5F  call console_putc_16

58              # POP_AX        ; restore original al
50              # PUSH_AX       ;

24 0F           # and al, 0x0F
3C 09           # cmp al, 9
7F 04           # jg alpha
#29

#numeral:
04 30           # add al, 0x30
EB 02           # jmp print2

#alpha:
04 37           # add al, 0x37
#35

#print2:
9A 5F 7C 00 00  # CALL 00007C5F  call console_putc_16

B0 0A           # mov al, 0x0a
9A 5F 7C 00 00  # CALL 00007C5F  call console_putc_16

58              # POP_AX
CB              # retf


# ------------------------
#[7CA6][14]
#:console_puts_16 (ds:si = string)
#:puts_16_loop
#
AC              # lodsb  al=[ds:si++]
84 C0           # test al, al
74 07           # jz end_loop
9A 5F 7C 00 00  # CALL 00007C5F  call console_putc_16
EB F4           # jmp puts_16_loop

#:end_loop
B0 0A           # mov al, 0A
9A 5F 7C 00 00  # CALL 00007C5F  call console_putc_16
CB              # RETF


#[7CBA][16]
# ------------------------
#:get_partition_start_16(al=partition_num 1..4)
#returns:
# cx = cylinder/sector
# dh = head
#
50              # PUSH_AX
56              # PUSH_SI

BB 10 00        # mov bx, 0x0010     ; bx = partition_length
30 E4           # xor ah, ah
F7 E3           # mul bx             ; entry_offset = partition_num * bx
89 C6           # mov si, ax         ; si = entry_offset
BB AF 7D        # mov bx, 7DAF       ; bx = &partition_table[-1]
8A 30           # mov dh, [bx+si]    ; dh = head = partition_table[al][0]
8B 48 01        # mov cx, [bx+si+1]  ; cx = cyl/sector = partition_table[al][1]

5E              # POP_SI
58              # POP_AX
CB              # retf


#[7CD0][18]
# ------------------------
#:get_drive_geometry(dl)
#
06              # PUSH_ES
57              # PUSH_DI

# https://en.wikipedia.org/wiki/INT_13H#INT_13h_AH=08h:_Read_Drive_Parameters
31 FF           # xor di, di
8E C7           # mov es, di
B4 08           # mov ah, 8       ; get drive parameters
CD 13           # INT_13

88 36 14 7C     # mov 0x7C14, dh
80 E1 3F        # and cl, 0x3f
88 0E 15 7C     # mov 0x7C15, cl

5F              # POP_DI
07              # POP_ES
CB              # retf


#[7CE8][37]
# ------------------------
#:next_sector(cx=cylinder/sector, dh = head)
#
50              # PUSH_AX

88 C8           # mov al, cl          ; get sector number
24 3F           # and al, 0x3f
3C 3F           # cmp al, 0x3f        ; if sector_num == 63
74 04           # jz next_head        ;      goto next_head
FE C1           # inc cl              ; else sector_num++;
EB 28           # jmp cleanup

#next_head:
3A 36 14 7C     # cmp dh, [0x7C14]    ; if head_num == num_heads
74 09           # jz next_cylinder    ;      goto next_cyclinder
FE C6           # inc dh              ; else head_num++
80 E1 C0        # and cl, 0xc0        ;      sector_num = 1
FE C1           # inc cl              ;
EB 19           # jmp cleanup

#next_cylinder:
80 FD FF        # cmp ch, 0xff        ; if cylinder_low == 255
75 0B           # jnz next_cyl_high

#next_cyl_low:
30 F6           # xor dh, dh          ; head_num = 0
80 E1 C0        # and cl, 0xc0        ; sector_num = 0
81 C1 01 01     # add cx, 0x0101      ; cylinder_low++, sector_num++
EB 09           # jmp cleanup

#next_cyl_high:
30 F6           # xor dh, dh          ; head_num = 0
81 C1 C0 00     # and cx, 0x00C0      ; cylinder_low = 0, sector_num = 0
80 C1 41        # add cl, 0x41        ; cylinder_high++, sector_num++

#cleanup:
58              # POP_AX
CB              # retf


#[7D1F][29]
#:read_sectors_16(di = *dest_addr, cx=cylinder/sector, dh = head, ax=num_sectors)
#
# returns: di - next byte to write to
#          cx,dh - next disk sector to read from
#
50              # PUSH_AX
53              # PUSH_BX
56              # PUSH_SI

89 C6            # mov si, ax      ; si=num_sectors
89 FB            # mov bx, di      ; int 13 writes to bx

#:read_one_loop
8A 16 13 7C     # mov dl, [0x7C13] ; boot disk
B4 02           # mov ah, 2       ; rw mode = 02 (read)
B0 01           # mov al, 1       ; num_sectors
CD 13           # INT_13
72 F4           # jnc read_one_loop
3C 01           # cmp al, 1
75 F0           # jnz read_one_loop

#19
# advance and maybe continue
9A E8 7C 00 00  # call next_sector

# we read one sector, advance
81 C3 00 02     # add bx, 0x200
#28
4E              # dec si          ; num_sectors--
75 E4           # jnz read_one_loop

89 DF           # mov di, bx

5E              # POP_SI
5B              # POP_BX
58              # POP_AX
CB              # RETF
#37


#[7D48][19]
#:mbr_main (dl=boot_drive)
# Load the kernel and jump to it
88 16 13 7C     # mov 0x7C13, dl   ; save boot drive
9A D0 7C 00 00  # CALL get_drive_geometry()
BF 00 7E        # mov di, 0x7E00   ; place kernel after MBR in memory
B8 06 00        # mov ax, 0x0006   ; num_sectors = 6
B9 02 00        # LOADI16_CX 0002  ; cylinder = 0, sector_num = 0x02
B6 00           # LOADI8_DH 00     ; head = 0
9A 1F 7D 00 00  # call read_sectors_16
EA 00 7E 00 00  # JMP 00007E00  jmp kern_main


# ------------------------------------------------------------
# This is the rest of the MBR.
#
#[7D  ]
                  00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
#[7D80]
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
#[7DB0]
00 00 00 00 00 00 00 00 00 00 00 00 00 00

# Partition entry 1
#[7DBE]
# status inactive
00
# first head,sector[0..5]+cylinder[8..9],cylinder[0..7]
00 01 00
# type non-fs data
DA
# last head,sector[0..5]+cylinder[8..9],cylinder[0..7]
00 00 00
# LBA start
00 00 00 00
# Num sectors
00 00 00 00

# Partition entry 2
#[7DCE]
# status inactive
00
# first head,sector[0..5]+cylinder[8..9],cylinder[0..7]
00 02 00
# type "non-fs data"
DA
# last head,sector[0..5]+cylinder[8..9],cylinder[0..7]
00 00 00
# LBA start
00 00 00 00
# Num sectors
00 00 00 00

# Partition entry 3
# status inactive
00
# first head,sector[0..5]+cylinder[8..9],cylinder[0..7]
00 03 00
# type "non-fs data"
DA
# last head,sector[0..5]+cylinder[8..9],cylinder[0..7]
00 00 00
# LBA start
00 00 00 00
# Num sectors
00 00 00 00

# Partition entry 4
# status inactive
00
# first head,sector[0..5]+cylinder[8..9],cylinder[0..7]
00 08 00
# type "non-fs data"
DA
# last head,sector[0..5]+cylinder[8..9],cylinder[0..7]
00 00 00
# LBA start
00 00 00 00
# Num sectors
00 00 00 00

#[7DFE]
# This is the DOS/MBR identifier at offset 510:
55 AA

#------------------------------------------------------------
# The kernel entry point
#------------------------------------------------------------
#:kern_main
#[7E00][14]

EA 36 7E 00 00  # JMP jmp start_32bit_main

# alignment
90 90 90

#---------------------------------------------
# The Global Descriptor Table for 32 bit mode.
#---------------------------------------------
#[7E08]
#:GDT_start:
00 00 00 00 00 00 00 00

#7E10 [+08]
#:GDT_code32:
FF FF # limit 0:15
00 00 # base  0:15
00    # base 16:23
9A    # access byte 10011010b
      #   present=1 privilege=00 type=1
      #   code=1 conforming=0 readable=1 accessed=0
CF    # 11001111b
      #   granularity=1 32-bit-default=1 64-bit seg=0 AVL=0
00    #

#7E18 [+10]
#:GDT_data32:
FF FF # limit 0:15
00 00 # base  0:15
00    # base 16:23
92    # access byte 10010010b 
      #   present=1 privilege=00 type=1
      #   code=0 conforming=0 readable=1 accessed=0
CF    # flags, limit 16:19 11001111b  
      #   granularity=1 32-bit-default=1 64-bit seg=0 AVL=0
00    # base 24:31

#7E20 [+18]
#:GDT_code16:
FF FF # limit 0:15
00 00 # base  0:15
00    # base 16:23
9A    # access byte 10011010b
      #   present=1 privilege=00 type=1
      #   code=1 conforming=0 readable=1 accessed=0
8F    # 10001111b
      #   granularity=1 32-bit-default=0 64-bit seg=0 AVL=0
00    #

#7E28 [+20]
#:GDT_data16:
FF FF # limit 0:15
00 00 # base  0:15
00    # base 16:23
92    # access byte 10010010b 
      #   present=1 privilege=00 type=1
      #   code=0 conforming=0 readable=1 accessed=0
8F    # flags, limit 16:19 10001111b  
      #   granularity=1 32-bit-default=0 64-bit seg=0 AVL=0
00    # base 24:31

#7E30
#:GDT_locator
27 00        #  length
08 7E 00 00  #  GDT_start


# ------------------------------------------------------------
# Kernel Functions
# ------------------------------------------------------------

#----------------------------------------
#[7E36][3D]
#:start_32bit_main()
B8 01 24              # mov ax,2401h     # enable A20 line
CD 15                 # int 15h

FA                    # cli
0F 01 16 30 7E        # lgdt GDT_locator
0F 20 C0              # mov eax, cr0
66 83 C8 01           # or eax, 0x01
0F 22 C0              # mov cr0, eax
EA 50 7E 08 00        # JMP jmp setup_32bit
#[7E50][@1A][23]
#:setup_32bit
66 B8 10 00           # mov ax, 0x0010      ; data descriptor
8E D8                 # mov ds, ax
8E D0                 # mov ss, ax
8E C0                 # mov es, ax
8E E0                 # mov fs, ax
8E E8                 # mov gs, ax
BD 0F FF 1F 00        # mov ebp, 0x1FFFF0
89 EC                 # mov esp, ebp

9A 73 7E 00 00 08 00  # call setup_interrupt_handlers
9A 9A 86 00 00 08 00  # call app_main


#----------------------------------------
#[7E73][40]
#:setup_interrupt_handlers
53                    # push ebx

# handle the timer interrupt 08
BB 40 00 01 00        # mov ebx, &interrupt_table[08]
66 C7 03 B9 7E        # mov word [ebx + 0], low_address stub_interrupt_handler
66 C7 43 06 00 00     # mov word [ebx + 6], high_address
66 C7 43 02 08 00     # mov word [ebx + 2], code_segment = 0x0800
C6 43 05 8E           # mov byte [ebx + 5], flags = 8E

# handle int 80
BB 00 04 01 00        # mov ebx, &interrupt_table[80]
66 C7 03 C8 7F        # mov word [ebx + 0], low_address syscall_interrupt_handler
66 C7 43 06 00 00     # mov word [ebx + 6], high_address
66 C7 43 02 08 00     # mov word [ebx + 2], code_segment = 0x0800
C6 43 05 8E           # mov byte [ebx + 5], flags = 8E

# load the interrupt table
FA                    # cli
0F 01 1D B3 7E 00 00  # lidt [0x00007EB3] IDT_locator_32
FB                    # sti
5B                    # pop ebx
CB                    # retf


#----------------------------------------
#[7EB3][06]
#:IDT_locator_32
FF 07        #  length
00 00 01 00  #  IDT_start


#----------------------------------------
#stub_interrupt_handler
#[7EB9]
CF                    # iret


#------------------------------------------------------------
# 32 -> 16 -> 32 bit switching functions
#------------------------------------------------------------
# When switching between real mode and
# protected, registers are stored here:
#
# 7B14  edx
# 7B10
# 7B0C
# 7B08  eax
# 7B04  esp
#
# 7B00  <- top of real mode stack


#----------------------------------------
#[7EBA][61]
#:enter_16bit_real
FA                    # cli
A3 08 7B 00 00        # mov [0x7B08], eax  ; preserve so we can use these locally
89 15 14 7B 00 00     # mov [0x7B14], edx  ;
5A                    # pop edx            ; capture return address
89 25 04 7B 00 00     # mov [0x7B04], esp  ; capture stack

# The following far jump sets CS to a 16-bit protected mode selector
# and the segment registers are also set to 16-bit protected mode selectors.
# This is done prior to entering real mode.
EA D4 7E 00 00 18 00  # jmp 0x18:setup_16bit
#[7ED4]
#:setup_16bit
B8 20 00              # mov eax, 0x0020
8E D0                 # mov ss, eax
8E D8                 # mov ds, eax
8E C0                 # mov es, eax
8E E8                 # mov gs, eax
8E E0                 # mov fs, eax
BC 00 7B              # mov sp, 0x7B00
0F 20 C0              # mov eax, cr0
66 83 E0 FE           # and eax, 0xfffffffe  ; clear protected mode
0F 22 C0              # mov cr0, eax
# The following far jump sets CS to a 16-bit real mode segment
# and the segment registers are also set to real mode segments.
EA F3 7E 00 00        # jmp 0000:XXXX  real_mode
#[7EF3]
#:real_mode
B8 00 00              # mov ax, 0x0
8E D8                 # mov ds, ax
8E E0                 # mov fs, ax
8E E8                 # mov gs, ax
8E D0                 # mov ss, ax
8E C0                 # mov es, ax
BC 00 7B              # mov sp, 0x7B00
FA                    # cli
0F 01 1E 15 7F        # lidt IDT
FB                    # sti
# Using retf to set CS comes from here:
# https://stackoverflow.com/questions/26448480/bios-interrupts-in-protected-mode
# This page recommends a far jump followed by sti:
# https://www.sudleyplace.com/pmtorm.html
6A 00                 # push 0x0000 (2 bytes!)  CS to return to
52                    # push dx  IP to return to
A1 08 7B              # mov ax, [0x7B08]  ; restore from above
8B 16 14 7b           # mov dx, [0x7B14]
CB                    # retf

# IDT
#[7F15]
FF FF
00 00 00 00


#----------------------------------------
#[7F1B][40]
#:resume_32bit_mode()
# modifies: ebp and all segment registers
FA                    # cli
A3 08 7B              # mov [0x7B08], ax  ; preserve, they might be return values from 16 bit
89 16 14 7b           # mov [0x7B14], dx
5A                    # pop dx      ; carry the return IP in dx
58                    # pop ax      ; CS
0F 01 16 30 7E        # lgdt GDT_locator
0F 20 C0              # mov eax, cr0
66 83 C8 01           # or eax, 0x01         ; enable protected mode
0F 22 C0              # mov cr0, eax
EA 39 7F 08 00        # JMP restore_32bit
#[7F39]
#:restore_32bit
B8 10 00 00 00        # mov eax, 0x0010      ; data descriptor
8E D8                 # mov ds, eax
8E D0                 # mov ss, eax
8E C0                 # mov es, eax
8E E0                 # mov fs, eax
8E E8                 # mov gs, eax
8B 25 04 7B 00 00     # mov esp, [0x7B04]   ; restore, (saved in enter_16bit_mode)
9A 73 7E 00 00 08 00  # call setup_interrupt_handlers
52                    # push edx            ; setup our return location
# These restore the 16 bit portion of these registers, which may be a
# return value from a 16 bit function, and they also restore any previous high
# bits that were stored by enter_16bit_mode so these registers need not be
# saved when going to 16 bit mode and back if you want them left alone.
A1 08 7B 00 00        # mov eax, [0x7B08]   ; restore, (saved at top of this function)
8B 15 14 7B 00 00     # mov edx, [0x7B14]
C3                    # ret


# ------------------------
#[7F62][10]
#:console_putc:
#
E8 53 FF FF FF  # CALL enter_16bit_real, next=[7F67]
9A 5F 7C 00 00  # CALL console_putc_16(al)
9A 1B 7F 00 00  # CALL resume_32bit_mode
CB              # RETF


# ------------------------
#:console_put_hex
#[7F72][10]
E8 43 FF FF FF  # CALL enter_16bit_real, next=[7F77]
9A 75 7C 00 00  # CALL console_put_hex_16(al)
9A 1B 7F 00 00  # CALL resume_32bit_mode
CB              # RETF


# ------------------------
#[7F82][1A]
#:console_puts (ds:si = string)
#:puts_loop
50                    # push eax
56                    # push esi
8A 06                 # mov al, [esi]
3C 00                 # cmp al, 0
74 0A                 # jz end_loop
9A 62 7F 00 00 08 00  # call console_putc
46                    # inc esi
EB F0                 # jmp puts_loop
#:end_loop
B0 0A                 # mov al, 0A
9A 62 7F 00 00 08 00  # call console_putc
5E                    # pop esi
58                    # pop eax
CB                    # RETF


#[7FA0][18]
# ------------------------
#:get_partition_start(eax=partition_num 1..4)
#returns:
# cx = cylinder/sector
# dh = head
#
50              # PUSH_EAX
56              # PUSH_ESI

6B C0 10        # imul eax, 0x10
89 c6           # mov esi, eax         ; esi = entry_offset
BB AE 7D 00 00  # mov ebx, 7DAE        ; ebx = &partition_table[-1]
8A 74 33 01     # mov dh, [ebx+esi+1]  ; dh = head = partition_table[al][0]
66 8B 4C 33 02  # mov cx, [ebx+esi+2]  ; cx = cyl/sector = partition_table[al][1]

5E              # POP_ESI
58              # POP_EAX
CB              # retf


# ------------------------
#[7FB8][10]
#:read_sectors(di = *dest_addr, cx=cylinder/sector, dh = head, ax=num_sectors)
E8 FD FE FF FF  # CALL enter_16bit_real, next=[7FBD]
9A 1F 7D 00 00  # CALL read_sectors_16
9A 1B 7F 00 00  # CALL resume_32bit_mode
CB              # RETF


# ------------------------
#[7FC8][29]
#:syscall_interrupt_handler
83 F8 01              # cmp eax, 1
75 08                 # jne try next
9A 7D 83 00 00 08 00  # call handle_syscall_exit
CF                    # iret

83 F8 02              # cmp eax, 2
75 08                 # jne try next
9A 44 82 00 00 08 00  # call handle_syscall_fork
CF                    # iret

83 F8 03              # cmp eax, 3
75 08                 # jne try next
9A 17 81 00 00 08 00  # call handle_syscall_read
CF                    # iret

83 F8 04              # cmp eax, 4
75 08                 # jne try next
9A F6 81 00 00 08 00  # call handle_syscall_write
CF                    # iret

83 F8 05              # cmp eax, 5
75 08                 # jne try next
9A 40 80 00 00 08 00  # call handle_syscall_open
CF                    # iret

83 F8 07              # cmp eax, 7
75 08                 # jne try next
9A 5B 83 00 00 08 00  # call handle_syscall_waitpid
CF                    # iret

83 F8 0B              # cmp eax, B
75 08                 # jne try next
9A 7F 82 00 00 08 00  # call handle_syscall_execve
CF                    # iret

83 F8 2D              # cmp eax, 2D
75 08                 # jne try next
9A C3 81 00 00 08 00  # call handle_syscall_brk
CF                    # iret


#[8030][08]
#s  c  /  o  p  e  n \0
73 63 2F 6F 70 65 6E 00

#[8038][04]
# next_filenum
04 00 00 00

#[803C][04]
# next_file_address
00 00 50 00

#------------------------------------------------------------
#[8040][20]
#:handle_syscall_open(ebx=filename, ecx=flags)
56                    # push esi
57                    # push edi
51                    # push ecx

BE 30 80 00 00        # mov esi, "sc/open"
9A 82 7F 00 00 08 00  # call console_puts

89 DE                 # mov esi, ebx
9A 82 7F 00 00 08 00  # call console_puts

F7 C1 01 00 00 00     # test ecx, 1
74 59                 # jz open_read

# copy filename to new slot
89 DE                 # mov esi, ebx
BF 00 00 40 00        # mov edi, 0x0400000
A1 38 80 00 00        # mov eax, [&next_filenum]
C1 E0 0A              # shl eax, 0a
01 C7                 # add edi, eax
B9 00 04 00 00        # mov ecx, 0x0000400
F3 A4                 # rep movsb

# set address of file
BF 00 08 01 00        # mov edi, 0x0010800            ; pfile_descriptor = &file_descriptor[0]
A1 38 80 00 00        # mov eax, [&next_filenum]
C1 E0 04              # shl eax, 04
01 C7                 # add edi, eax                  ; pfile_descriptor += sizeof(file_descriptor) * next_filenum
8B 0D 3C 80 00 00     # mov ecx, [next_file_address]
C7 01 00 00 00 00     # mov long [ecx], 0             ; *next_addr = 0  (put a zero between files, not really necessary?)
41                    # inc ecx
89 0D 3C 80 00 00     # mov [next_file_address], ecx  ; next_file_addr++
89 4F 04              # mov [edi+4], ecx              ; pfile_descriptor->file_addr = ecx
C7 47 08 00 00 00 00  # mov long [edi+8], 0           ; pfile_descriptor->length = 0

A1 38 80 00 00        # mov eax, [next_filenum]
40                    # inc eax
A3 38 80 00 00        # mov [next_filenum], eax  ; next_filenum++
48                    # dec eax
9A 72 7F 00 00 08 00  # call console_put_hex
EB 18                 # jmp finish

#open_read
9A D5 80 00 00 08 00  # call find_file
89 C2                 # mov edx, eax
# set read offset to start of file
BE 00 08 01 00        # mov esi, 0x0010800       ; pfile_descriptor = &file_descriptor[0]
C1 E2 04              # shl edx, 04
01 D6                 # add esi, edx             ; pfile_descriptor += sizeof(file_descriptor) * filenum
31 D2                 # xor edx, edx
89 56 0C              # mov [esi+0xC], edx       ; current offset = 0

# finish
59                    # pop ecx
5F                    # pop edi
5E                    # pop esi
CB                    # ret


#----------------------------------------
#[80D5]
#:find_file(char * ebx=file_name) returns eax=filenum
51                    # push ecx
52                    # push edx
56                    # push esi
57                    # push edi

BA 04 00 00 00        # mov edx, 4              ; filenum = 4
#check file
89 DE                 # mov esi, ebx
BF 00 00 40 00        # mov edi, 0x0400000      ; pfile_name = &file_name[0]
89 D0                 # mov eax, edx
C1 E0 0A              # shl eax, 0a
01 C7                 # add edi, eax            ; pfile_name += sizeof(file_name) * filenum

B9 00 04 00 00        # mov ecx, 0x0000400
F3 A6                 # rep cmpsb
74 11                 # je match

# if not on last file, continue checking
42                    # inc edx
A1 38 80 00 00        # mov eax, [next_filenum]
39 C2                 # cmp edx, eax
75 DF                 # jne checkfile

#no match
B8 FF FF FF FF        # mov eax, 0xffffffff
EB 02                 # jmp finish

#match
89 D0                 # mov eax, edx

#finish
5F                    # pop edi
5E                    # pop esi
5A                    # pop edx
59                    # pop ecx
CB                    # ret


90 90 90 90 90 90 90 90
90 90


#------------------------------------------------------------
#[8117][70]
#:handle_syscall_read(ecx=*return_char, ebx=file)
53                    # push ebx
51                    # push ecx
52                    # push edx
56                    # push esi
57                    # push edi

51                    # push ecx   ; we need this later to return char
83 FB 00              # cmp ebx, 0
75 6A                 # jne memfile

# stdin is /dev/hda4
# get current position
66 8B 0D 00 08 01 00  # mov cx, [0x10800]  ; cyl/sector
8A 35 02 08 01 00     # mov dh, [0x10802]  ; head
31 C0                 # xor eax, eax
66 A1 04 08 01 00     # mov ax, [0x10804]  ; offset
#end of sector?
66 3D ff 01           # cmp ax, 0x01ff
74 04                 # je next sector

#nextchar:
66 40                 # inc ax
EB 2A                 # jmp getchar

#read next sector
BF 00 A0 00 00        # mov edi, 0x000A000
B8 01 00 00 00        # mov eax, 0x0001   ; num_sectors = 1
9A B8 7F 00 00 08 00  # call read_sectors

# save new location and offset
66 89 0D 00 08 01 00  # mov [0x10800], cx
88 35 02 08 01 00     # mov [0x10802], dh
31 C0                 # xor eax, eax

# move block to device buffer
BE 00 A0 00 00        # mov esi, 0x000A000
BF 00 00 04 00        # mov edi, 0x0040000
B9 00 02 00 00        # mov ecx, 0x0000200
F3 A4                 # rep movsb

#getchar:
66 A3 04 08 01 00     # mov [0x10804], ax
59                    # pop ecx
BB 00 00 04 00        # mov ebx, 0x40000    ; device buffer
89 C6                 # mov esi, eax        ; offset
8A 04 33              # mov al, [ebx+esi+0]
88 01                 # mov [ecx], al
B8 01 00 00 00        # mov eax, 1
EB 2D                 # jmp finish

#memfile:

# get file address
BE 00 08 01 00        # mov esi, 0x0010800     ; pfile_descriptor = &file_descriptor[0]
89 D9                 # mov ecx, ebx
C1 E1 04              # shl ecx, 04
01 CE                 # add esi, ecx           ; pfile_descriptor += sizeof(file_descriptor) * filenum
8B 4E 04              # mov ecx, [esi+4]       ; mov ecx, pfile_descriptor->file_address
# get current read offset from descriptor
8B 56 0C              # mov edx, [esi+0C]      ; mov edx, pfile_descriptor->current_offset
FF 46 0C              # inc long [esi+0C]      ; pfile_descriptor->current_offset++
8b 46 08              # mov eax, [esi+0x08]    ; pfile_descriptor->file_length++
48                    # dec eax
39 C2                 # cmp edx, eax
7F 0D                 # jg eof                 ; read_offset > file_length - 1 ?

8A 04 11              # mov al, [ecx+edx]      ; al = *(file_address + current_offset)
59                    # pop ecx                ; restore saved return pointer
88 01                 # mov [ecx], al          ; *(return_pointer) = al
B8 01 00 00 00        # mov eax, 1             ; read one byte
EB 03                 # jmp finish

#eof:
31 C0                 # xor eax, eax           ; read zero bytes
59                    # pop ecx                ; ignore saved return pointer

#finish:
5F                    # pop edi
5E                    # pop esi
5A                    # pop edx
59                    # pop ecx
5B                    # pop ebx
CB                    # ret


#[81BF]
#b  r  k
62 72 6b 00

#[81C3]
#------------------------------------------------------------
#:handle_syscall_brk
BE BF 81 00 00        # mov esi, &"brk"
9A 82 7F 00 00 08 00  # call console_puts
A1 77 82 00 00        # mov eax, [&next_process_num]
48                    # dec eax = current process

BE 00 00 02 00        # mov esi, 0x0020000       ; pproc_descriptor = &proc_descriptor[0]
C1 E0 04              # shl eax, 04
01 C6                 # add esi, eax             ; pproc_descriptor += sizeof(proc_descriptor) * procnum

85 DB                 # test ebx, ebx
74 06                 # jz get

# set
89 5E 04              # mov [esi+4], ebx
89 D8                 # mov eax, ebx
CB

# get
8B 46 04              # mov eax, [esi+4]         ; pproc_descriptor->brk
CB

00 00 00 00
00 00 00 00
00


#------------------------------------------------------------
#[81F6]
#:handle_syscall_write(ebx=file,ecx=*char_to_write)
50                    # push eax
51                    # push ecx
52                    # push edx
56                    # push esi

# get char to write
8A 01                 # mov al, [ecx]

# stdout?
83 FB 01              # cmp ebx, 01
75 09                 # jnz memfile

# stdout -> console_out
9A 62 7F 00 00 08 00  # call console_putc
EB 30                 # jmp finish

#memfile
#ebx=filenum
# get file address
BE 00 08 01 00        # mov esi, 0x0010800   ; pfile_descriptor = &file_descriptor[0]
89 D9                 # mov ecx, ebx
C1 E1 04              # shl ecx, 04
01 CE                 # add esi, ecx         ; pfile_descriptor += sizeof(file_descriptor) * filenum
8B 4E 04              # mov ecx, [esi+4]     ; mov ecx, pfile_descriptor->file_address
# get current write offset from descriptor
8b 56 0c              # mov edx, [esi+0xC]   ; mov edx, current offset
ff 46 0c              # inc long [esi+0xC]   ; current_offset++
ff 46 08              # inc long [esi+0x8]   ; file_length++

01 D1                 # add ecx, edx
88 01                 # mov [ecx], al

#9A 72 7F 00 00 08 00  # call console_put_hex
90 90 90 90 90 90 90

89 0D 3C 80 00 00     # mov ecx, [0x803C]    ; next_file_address
41                    # inc ecx              ; *next_file_addr++
89 0D 3C 80 00 00     # mov [0x803C], ecx

#finish
5E                    # pop esi
5A                    # pop edx
59                    # pop ecx
58                    # pop eax
CB                    # ret

#[823F]
#f  o  r  k
66 6F 72 6B 00

#[8244]
#:handle_syscall_fork
BE 3F 82 00 00        # mov esi, "fork"
9A 82 7F 00 00 08 00  # call console_puts
A1 77 82 00 00        # mov eax, [&next_process_num]
48                    # dec eax = current process
BE 00 00 02 00        # mov esi, 0x0020000       ; pproc_descriptor = &proc_descriptor[0]
C1 E0 04              # shl eax, 04
01 C6                 # add esi, eax             ; pproc_descriptor += sizeof(proc_descriptor) * procnum
89 66 08              # mov [esi+0x8], esp       ; save stack pointer so we can return again later
#31 C0                 # xor eax, eax             ; return as child
90 90
CB                    # ret

00 00 00 00 00 00 00 00 00


#[826F]
#s  c  /  e  x  e  c
73 63 2F 65 78 65 63 00

#[8277][04]
# next_process_num
01 00 00 00

#[827B][04]
# next_process_address
00 00 80 00

#----------------------------------------
#[827F]
#:handle_syscall_execve
BE 6F 82 00 00        # mov esi, "exec"
9A 82 7F 00 00 08 00  # call console_puts
CB                    # ret


00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00


#----------------------------------------
#[82B0]
#:run
# argc at [esp+8]
# program name at [esp+C]
# arg1 at [esp+0xc]
8B 5C 24 0C           # mov ebx, [esp + 0xC]
9A D5 80 00 00 08 00  # call find_file
9A 72 7F 00 00 08 00  # call put_hex

# get file address and length
BA 00 08 01 00        # mov edx, 0x0010800       ; pfile_descriptor = &file_descriptor[0]
C1 E0 04              # shl eax, 04
01 C2                 # add edx, eax             ; pfile_descriptor += sizeof(file_descriptor) * filenum
8B 4A 08              # mov ecx, [edx+0x8]       ; ecx = pfile_descriptor->file_length
89 C8                 # mov eax, ecx
9A 72 7F 00 00 08 00  # call put_hex
8B 72 04              # mov esi, [edx+0x4]       ; esi = pfile_descriptor->file_address

# get proc entry point from file image
8B 46 3C              # mov eax, [esi + 0x3C]    ; get declared process address
25 FF FF 00 00        # and eax, 0x0000FFFF      ; mask off high bits to get local addr

# calc process image beginning
8B 3D 7B 82 00 00     # mov edi, [&next_process_address]
09 C7                 # or edi, eax              ; use low bits from declared entry point

51                    # push ecx
57                    # push edi
F3 A4                 # rep movsb
5F                    # pop edi
59                    # pop ecx

# record process in proc descriptor
BE 00 00 02 00        # mov esi, 0x0020000       ; pproc_descriptor = &proc_descriptor[0]
A1 77 82 00 00        # mov eax, [&next_process_num]
C1 E0 04              # shl eax, 04
01 C6                 # add esi, eax             ; pproc_descriptor += sizeof(proc_descriptor) * procnum
89 3E                 # mov [esi], edi           ; pproc_descriptor->address = edi
57                    # push edi
01 CF                 # add edi, ecx             ; set brk after code
89 7E 04              # mov [esi+4], edi         ; pproc_descriptor->brk
5F                    # pop edi

# prepare for next process
40                    # inc eax
A3 77 82 00 00        # mov [next_process_num], eax
57                    # push edi
81 C7 00 00 10 00     # add edi, 0x100000
89 3D 7B 82 00 00     # mov [&next_process_address], edi
5F                    # pop edi

# patch locations
57                    # push edi
89 FB                 # mov ebx, edi             ; new process address
C1 EB 10              # shr ebx, 16              ; mov high bytes to bx

# patch_loop
8B 07                 # mov eax, [edi]
3C 04                 # cmp al, 04
75 0A                 # jne next
80 FC 08              # cmp ah, 08
75 05                 # jne next
##patch:
66 89 1F              # mov [edi], bx
47                    # inc edi
49                    # dec ecx
#next:
47                    # inc edi
49                    # dec ecx
75 EC                 # jnz patch_loop
5F                    # pop edi

# get entry point
8B 47 18              # mov eax, [edi+ 0x18]

## save return point TODO
5B                    # pop ebx             ; remove my return eip
5B                    # pop ebx             ; remove my return cs

FF E0                 # jmp eax
CB                    # ret

90 90
90 90
90 90 90 90 90
90 90 90 90 90
90 90 90 90 90


#----------------------
#[8353][08]
#w  a  i  t  p  i  d \0
77 61 69 74 70 69 64 00

#----------------------------------------
#:handle_syscall_waitpid
#[835B]
BE 53 83 00 00        # mov esi, "waitpid"
9A 82 7F 00 00 08 00  # call console_puts
CB                    # ret
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00


#[8378]
#e  x  i  t \0
65 78 69 74 00

#----------------------------------------
#:handle_syscall_exit
#[837D]
BE 78 83 00 00        # mov esi, "exit"
9A 82 7F 00 00 08 00  # call console_puts
CB                    # ret
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00



# ------------------------------------------------------------
# Utilities
# ------------------------------------------------------------


# ----------------------------------------
# variables for read
#
#[83B3]  char io_char
00
00  # free

#[83B5][26]
#:read
53                    # push ebx
51                    # push ecx
52                    # push edx
B8 03 00 00 00        # mov eax, 3   ; syscall=read
B9 B3 83 00 00        # mov ecx, &io_char
BA 01 00 00 00        # mov edx, 1

CD 80                 # int 80 syscall

3C 00                 # cmp al, 0
74 07                 # je finish

B4 01                 # mov ah, 1
A0 B3 83 00 00        # mov al, &io_char

#finish
5A                    # pop edx
59                    # pop ecx
5B                    # pop ebx
CB                    # ret


#[83D8][26]
#:write
50                    # push eax
53                    # push ebx
51                    # push ecx
52                    # push edx

A2 B3 83 00 00        # mov &io_char, al
B8 04 00 00 00        # mov eax, 4   ; syscall=write
B9 B3 83 00 00        # mov ecx, &io_char
BA 01 00 00 00        # mov edx, 1   1 byte characters
CD 80                 # int 80 syscall

5A                    # pop edx
59                    # pop ecx
5B                    # pop ebx
58                    # pop eax
CB                    # ret


#[83F7][0F]
#:read_line(ebx=file, edi=linemem)
50                    # push eax
9A B5 83 00 00 08 00  # call read
AA                    # stosb
3C 0A                 # cmp al, '\n'
75 F4                 # jne read_line
58                    # pop eax
CB                    # ret


#[8406][0F]
#:write_line(ebx=file, esi=linemem)
50                    # push eax
#write_char
AC                    # lodsb
9A D8 83 00 00 08 00  # call write
3C 0A                 # cmp al, '\n'
75 F4                 # jne write_char

58                    # pop eax
CB                    # ret


#[8415][04]
#s  r  c \0
73 72 63 00

#----------------------------------------
# src: create file from stdin
#
# Read an integer, N, in decimal from stdin.
# Read a space.
# Then, read a file name to create.
# Read a newline.
# Then, read N lines from stdin and write to the new file.
#[8419]
#:src
50                    # push eax
53                    # push ebx
51                    # push ecx
52                    # push edx
56                    # push esi
57                    # push edi

31 C9                 # xor ecx, ecx        ; line count=0

90 90

BE 15 84 00 00        # mov esi,  "src"
9A 82 7F 00 00 08 00  # call console_puts

9A B5 83 00 00 08 00  # call read 'r'
9A B5 83 00 00 08 00  # call read 'c'
9A B5 83 00 00 08 00  # call read ' '

#parse_line_count_loop:
9A B5 83 00 00 08 00  # call read
3C 20                 # cmp al, ' '
74 0C                 # je got count

6B C9 0A              # imul ecx, ecx, 10   ; count = count * 10
2C 30                 # sub al, 30
0F B6 C0              # movzx eax, al
01 C1                 # add ecx, eax        ; count += digit

EB E9                 # jmp parse_line_count_loop

# got_count:
88 E8                 # mov al, ch
9A 72 7F 00 00 08 00  # call put_hex
88 C8                 # mov al, cl
9A 72 7F 00 00 08 00  # call put_hex

# clear arguments
51                    # push ecx
31 C0                 # xor eax, eax
BA 00 00 20 00        # mov edx, 0x00200000
B9 00 08 00 00        # mov ecx, 0x00000800
90
#zeroloop
88 02                 # mov [edx], al
42                    # inc edx
49                    # dec ecx
75 FA                 # jnz zeroloop
59                    # pop ecx

90 90 90 90
90 90 90 90
90 90

51                    # push ecx
B9 00 00 20 00        # mov ecx, 0x00200000
# get_filename_loop:
9A B5 83 00 00 08 00  # call read

90 90 90 90 90 90 90
90 90

3C 0A                 # cmp al, '\n'
74 05                 # je got_filename
88 01                 # mov [ecx], al
41                    # inc ecx
EB E7                 # jmp get_file_name_loop
59                    # pop ecx

# got_filename:
BE 00 00 20 00        # mov esi, 0x00200000
9A 82 7F 00 00 08 00  # call console_puts

# open filename for write
51                    # push ecx
BB 00 00 20 00        # mov ebx, 0x00200000
B8 05 00 00 00        # mov eax, 5  ; syscall_open
B9 41 02 00 00        # mov ecx, 0x00000241 O_TRUNC (0x200) | O_CREAT (0x40) | O_WRONLY (0x1)
BA 80 01 00 00        # mov edx, 0x00000180 S_IRUSR (0x100) | S_IWUSR (0x80)
CD 80                 # int 80
59                    # pop ecx

# eax has the open file number

# readwrite_loop:
BF 00 00 30 00        # mov edi, 0x00300000   ; io buffer
31 DB                 # xor ebx, ebx   ; ebx=0=stdin
9A F7 83 00 00 08 00  # call read_line
89 C3                 # mov ebx, eax          # prepare to write
BE 00 00 30 00        # mov esi, 0x00300000
9A 06 84 00 00 08 00  # call write_line
49                    # dec ecx   ; count--
75 E1                 # jnz read_write_loop

5F                    # pop edi
5E                    # pop esi
5A                    # pop edx
59                    # pop ecx
5B                    # pop ebx
58                    # pop eax
CB                    # ret


#[84F6][05]
#h  e  x  0 \0
68 65 78 30 00

#------------------------------------------------------------
#:hex0
#[84FB]
53                    # push ebx
56                    # push esi
57                    # push edi

BE F6 84 00 00        # mov esi,  "hex0"
9A 82 7F 00 00 08 00  # call console_puts
9A B5 83 00 00 08 00  # call read 'e'
9A B5 83 00 00 08 00  # call read 'x'
9A B5 83 00 00 08 00  # call read '0'
9A B5 83 00 00 08 00  # call read ' '

# clear arguments
31 C0                 # xor eax, eax
BA 00 00 20 00        # mov edx, 0x00200000
B9 00 08 00 00        # mov ecx, 0x00000800
#zeroloop
88 02                 # mov [edx], al
42                    # inc edx
49                    # dec ecx
75 FA                 # jnz zeroloop

BA 00 00 20 00        # mov edx, 0x00200000
#get_file_name1_loop
9A B5 83 00 00 08 00  # call read
3C 20                 # cmp al, ' '
74 05                 # je got_filename1
88 02                 # mov [edx], al
42                    # inc edx
EB F0                 # jmp get_file_name_loop

#got_filename1
BA 00 04 20 00        # mov edx, 0x00200400
#get_file_name2_loop
9A B5 83 00 00 08 00  # call read
3C 0A                 # cmp al, '\n'
74 05                 # je got_filename2
88 02                 # mov [edx], al
42                    # inc edx
EB F0                 # jmp get_file_name_loop

# open filename1 for read
BB 00 00 20 00        # mov ebx, 0x00200000
B8 05 00 00 00        # mov eax, 5  ; syscall_open
B9 00 00 00 00        # mov ecx, 0x00000000
CD 80                 # int 80

50                    # push eax  ; save read filenum

# open filename2 for write
BB 00 04 20 00        # mov ebx, 0x00200400
B8 05 00 00 00        # mov eax, 5  ; syscall_open
B9 41 02 00 00        # mov ecx, 0x00000241 O_TRUNC (0x200) | O_CREAT (0x40) | O_WRONLY (0x1)
BA 80 01 00 00        # mov edx, 0x00000180 S_IRUSR (0x100) | S_IWUSR (0x80)
CD 80                 # int 80
89 C2                 # mov edx, eax

59                    # pop ecx                 ; restore read filenum

# this flag is set after the first digit is seen
31 DB                 # xor ebx, ebx


#[858F]
#:read_loop
53                    # push ebx
89 CB                 # mov ebx, ecx
9A B5 83 00 00 08 00  # call read
5B                    # pop ebx
#f5

#9A 72 7F 00 00 08 00  # call put_hex
90 90 90 90 90 90 90
90 90 90 90

84 e4                 # test ah, ah
75 04                 # jnz check_command
5F                    # POP_DI
5E                    # POP_SI
5B                    # POP_BX
CB                    # RETF

#:check_command
3C 23                 # cmp al, '#'

#cf
74 28                 # jz skip_comment

3C 3B                 # cmp ';'
74 24                 # jz skip_comment

3C 66                 # cmp al, 'f'
7F C6                 # jg read_loop

3C 61                 # cmp al, 'a'
7C 04                 # jl maybe_upper

# Handle a to f
2C 57                 # sub al, 'a'-10 == 87 = 0x57
EB 29                 # jmp maybe_store

#:maybe_upper
3C 46                 # cmp al, 'F'
7F CA                 # jg read_loop

3C 41                 # cmp al, 'A'
7C 04                 # jl maybe_digit

# Handle A to F
2C 37                 # sub al, 'A'-10 == 55 = x37
EB 1D                 # jmp maybe_store

#:maybe_digit
3C 39                 # cmp al, '9'
7F BE                 # jg read_loop

3C 30                 # cmp al, '0'
7C BA                 # jl read_loop

# Handle 0 to 9
2C 30                 # sub al, '0' == x30
EB 11                 # jmp maybe_store

#:skip_comment
53                    # push ebx
89 CB                 # mov ebx, ecx
9A B5 83 00 00 08 00  # call read
5B                    # pop ebx
3C 0A                 # cmp al, '\n'
75 F1                 # jnz skip_comment
EB A5                 # jmp read_loop

# only store on second digit
#:maybe_store
84 DB                 # test bl, bl
75 09                 # jnz second_digit

# If on first digit, record and keep going
#:first_digit
C0 E0 04              # shl al, 4
88 C7                 # mov bh, al
FE C3                 # inc bl
EB 98                 # jmp read_loop

# If on second digit, store and clear state
#:second_digit
08 C7                 # or bh, al
88 F8                 # mov al, bh

53                    # push ebx
89 D3                 # mov ebx, edx
9A D8 83 00 00 08 00  # call write
5B                    # pop ebx

31 DB                 # xor bx, bx
EA 8F 85 00 00 08 00  # jmp read_loop



#------------------------------------------------------------
#:handle_other_command
#[860F]
BE 6F 82 00 00        # mov esi, "sc/exec"
9A 82 7F 00 00 08 00  # call console_puts

# clear arguments
BA 00 00 20 00        # mov edx, 0x00200000
88 02                 # mov [edx], al
42                    # inc edx
31 C0                 # xor eax, eax
B9 FF 07 00 00        # mov ecx, 0x000007FF
#zeroloop
88 02                 # mov [edx], al
42                    # inc edx
49                    # dec ecx
75 FA                 # jnz zeroloop

BA 01 00 20 00        # mov edx, 0x00200001
#get_program_name
9A B5 83 00 00 08 00  # call read
3C 20                 # cmp al, ' '
74 05                 # je got_program_name
88 02                 # mov [edx], al
42                    # inc edx
EB F0                 # jmp get_program_name

#got_program_name
BA 00 04 20 00        # mov edx, 0x00200400
#get_file_name2_loop
9A B5 83 00 00 08 00  # call read
3C 0A                 # cmp al, '\n'
74 05                 # je got_filename2
88 02                 # mov [edx], al
42                    # inc edx
EB F0                 # jmp get_file_name_loop

BE 00 00 20 00        # mov esi, program
9A 82 7F 00 00 08 00  # call console_puts

BE 00 04 20 00        # mov esi, arg1
9A 82 7F 00 00 08 00  # call console_puts

6A 00                 # push 0             ; null environment
6A 00                 # push 0             ; end args
68 00 04 20 00        # push arg1
68 00 00 20 00        # push arg0=program_name
68 02 00 00 00        # push argc=2

9A B0 82 00 00 08 00  # call run
CB

00 00 00 00 00 00 00 00 00 00 00 00 00

#[869A]
# ------------------------------------------------------------
# Main Program Body
# ------------------------------------------------------------
#:app_main (dl=boot_drive)
# Set up /dev/hda4 as global stdin
B8 04 00 00 00        # mov eax, 4
9A A0 7F 00 00 08 00  # call get_partition_start(4)

# save disk location and byte offset to descriptor
66 89 0D 00 08 01 00  # mov [0x10800], cx
88 35 02 08 01 00     # mov [0x10802], dh
# start at "end of sector" to trigger an initial sector read
66 B9 FF 01           # mov cx, 0x01FF
66 89 0D 04 08 01 00  # mov [0x10804], cx

# read from stdin
31 DB                 # xor ebx, ebx

#:process_command:
9A B5 83 00 00 08 00  # call read
3C 00                 # cmp al, 0           ; check_end
74 23                 # je finish_success

#check_src_command
3C 73                 # cmp al, 's'
75 09                 # jne check_hex0

#handle_src_command
9A 19 84 00 00 08 00  # call src
EB E8                 # jmp process_command

#check_hex0_command
3C 68                 # cmp al, 'h'
75 09                 # jne handle_other_command

#handle_hex0_command
9A FB 84 00 00 08 00  # call hex0
EB DB                 # jmp process_command

#handle_other_command:
#gather_other_command:
9A 0F 86 00 00 08 00  # call handle_other_command
EB D2                 # jmp process_command

#finish_success
#zero source
#call reboot
#:error_exit
BE 3F 7C 00 00        # mov esi, "Build finished."
9A 82 7F 00 00 08 00  # call console_puts

BE 16 7C 00 00        # mov esi, "Halting..."
9A 82 7F 00 00 08 00  # call console_puts

# one space to flush last line
B0 20                 # mov al, 20
9A 62 7F 00 00 08 00  # call console_putc

FA F4

# END Program Body


00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
#[8740]
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
#[8780]
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
#[87C0]
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
#[8800]
