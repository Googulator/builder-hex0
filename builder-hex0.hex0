# Builder-Hex0
#
# Builder-Hex0 is a small bootable machine image which has
# the ability to compile hex0 code. It is also written in hex0
# and so it can build itself if provided with its own source code.
#
# hex0 is a "language" for binary encoding in hexadecimal
# with support for comments.
#
# This file was hand assembled using this reference:
# http://www.mathemainzel.info/files/x86asmref.html
#

# ------------------------------------------------------------
# Stub Entry Point
#
# boot drive is in dl
#
#[7C00]
#:_start

# We cannot be sure the registers are initialized to zero so we
# do that first. Setting CS to zero requires a long jump so we
# jump to a routine (just past the globals) that will initialize
# the rest of the registers.
EA BB 7C 00 00 # JMP 00007CBB  jmp init_registers


# ------------------------------------------------------------
# Reserved for global data
#[7C05]
#H  a  l  t  i  n  g  .  .  . \r \n \0
48 61 6C 74 69 6E 67 2E 2E 2E 0D 0A 00

#[7C12]
#R  e  b  o  o  t  i  n  g  .  .  . \r \n \0
52 65 62 6F 6F 74 69 6E 67 2E 2E 2E 0D 0A 00

#[7C21]
#N  o     S  o  u  r  c  e    f   o  u  n  d  . \r \n \0
4E 6F 20 73 6F 75 72 63 65 20 66 6F 75 6E 64 2E 0D 0A 00

#[7C34]
#B  u  i  l  d     F  i  n  i  s  h  e  d  . \r \n \0
42 75 69 6C 64 20 66 69 6E 69 73 68 65 64 2E 0D 0A 00

#[7C46]
                  00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00

# ------------------------------------------------------------
# Global functions

# ------------------------
#[7C81]
#:halt
F4      # hlt
EB FD   # jmp halt

# ------------------------
#[7C84]
#:reboot
EA F0 FF 00 F0  # ljmp $F000:FFF0

# ------------------------
#[7C89]
#:putc (al=c)
53        # PUSH_BX
50        # PUSH_AX

# Prepare to use BIOS tty output interrupt.
# Specify text page 00, 0 black background, 7 light grey text
BB 00 07  # LOADI16_BX 0007
# Specify the `write character` BIOS routine
B4 0E     # LOADI8_AH  0E
CD 10     # INT_10

58        # POP_AX
5B        # POP_BX
CB        # RETF

# ------------------------
#[7C95]
#:puts (ds:si = string)
#:puts_loop
AC              # lodsb
84 C0           # test al, al
74 07           # jz end_loop
9A 89 7C 00 00  # CALL 00007C89  call putc
EB F4           # jmp puts_loop
#:end_loop
CB              # RETF

# ------------------------
# Reserved for global functions

#[7CA2]
      00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00

# ------------------------------------------------------------
# Main Entry Point
# We far jump here after entry to initialize the CS register.
# So this our real entry point. We initialize the registers
# and drop into main().
#[7CBB]
#:init_registers
31 C0     # xor ax, ax
8E D8     # COPY_AX_to_DS
8E C0     # COPY_AX_to_ES
8E D0     # COPY_AX_to_SS
BC 00 7C  # mov sp, 0x7C00

#[7CC6]
# ------------------------------------------------------------
# Main Program Body
#:main

# Load source code blocks
BB 00 AA  # LOADI16_BX AA00  ; destination address for read = ES:BX = 0000:AA00
B8 14 02  # LOADI16_AX 0201  ; rw mode = 02 (read),  num_sectors = 0x14
B9 16 00  # LOADI16_CX 0002  ; cylinder = 0, sector_num = 0x16
B6 00     # LOADI8_DH 00     ; head = 0
CD 13     # INT_13

# If there is no source jump down to the no_source handler
A0 00 AA         # mov AL, [AA00]
84 C0            # test al, al
74 2C            # jz no_source

9A 1B 7D 00 00  # CALL 00007D1B  run_build()

BE 34 7C        # mov si, 0x7C34
9A 95 7C 00 00  # CALL 00007C95  puts("Build finished.")

# zero the source image
B0 00           # LOADI8_AL 00
A2 00 AA        # mov [AA00], AL

# write the new image
BB 00 80       # LOADI16_BX 8000  ; source address for write = ES:BX = 0000:8000
B8 16 03       # LOADI16_AX 0201  ; rw mode = 03 (write),  num_sectors = 0x16
B9 01 00       # LOADI16_CX 0001  ; cylinder = 0, sector_num = 01
B6 00          # LOADI8_DH 00     ; head = 0
CD 13          # INT_13

# after a build occurs, invoke transition
BE 12 7C        # mov si, 0x7C12 si="Rebooting..."
9A 95 7C 00 00  # CALL 00007C95  puts(si)
9A 84 7C 00 00  # CALL 00007C84  reboot()

# This code handles when there is no source code.
#:no_source
BE 21 7C        # mov si, 0x7C05 si="No source found."
9A 95 7C 00 00  # CALL 00007C95  puts(si)

# we have no way to build now, so halt
BE 05 7C        # mov si, 0x7C20 si="Halting..."
9A 95 7C 00 00  # CALL 00007C95  puts(si)
9A 81 7C 00 00  # CALL 00007C81  halt()

#[7D1B]
# ----------------------------------------
# We run the build here.
#run_build():
53              # PUSH_BX
56              # PUSH_SI
57              # PUSH_DI

# this flag is set after the first digit is seen
31 DB           # xor bx,bx

# Start processing the source blocks
BE 00 AA        # mov si, 0xAA00
BF 00 80        # mov di, 0x8000

#:read_loop
AC              # lodsb

84 C0           # test al, al
74 4B           # jz end_read_loop

3C 23           # cmp al, '#'
74 2A           # jz skip_comment

3C 3B           # cmp ';'
74 26           # jz skip_comment

3C 66           # cmp al, 'f'
7F EF           # jg read_loop

3C 61           # cmp al, 'a'
7C 04           # jl maybe_upper

# Handle a to f

2C 57           # sub al, 'a'-10 == 87 = 0x57
EB 21           # jmp maybe_store

#:maybe_upper
3C 46           # cmp al, 'F'
7F E3           # jg read_loop

3C 41           # cmp al, 'A'
7C 04           # jl maybe_digit

# Handle A to F

2C 37           # sub al, 'A'-10 == 55 = x37
EB 15           # jmp maybe_store

#:maybe_digit
3C 39           # cmp al, '9'
7F D7           # jg read_loop

3C 30           # cmp al, '0'
7C D3           # jl read_loop

# Handle 0 to 9

90 90 # nop nop

2C 30           # sub al, '0' == x30
EB 07           # jmp maybe_store

#:skip_comment
AC              # lodsb
3C 0A           # cmp al, '\n'
75 FB           # jnz skip_comment

EB C6           # jmp read_loop

# only store on second digit
#:maybe_store
84 DB           # test bl, bl
75 09           # jnz second_digit

# If on first digit, record and keep going
#:first_digit
C0 E0 04        # shl al, 4
88 C7           # mov bh, al
FE C3           # inc bl
EB B9           # jmp read_loop

# If on second digit, store and clear state
#:second_digit
08 C7           # or bh, al
88 F8           # mov al, bh
AA              # stosb
31 DB           # xor bx, bx

EB B0           # jmp read_loop

#:end_read_loop
5F              # POP_DI
5E              # POP_SI
5B              # POP_BX
CB              # RETF
# END Program Body

# ------------------------------------------------------------
# This is the rest of the MBR.

#[7D80]
00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00

#[7DB0]
00 00 00 00 00 00 00 00 00 00 00 00 00 00

# Partition entry 1
#[7DBE]
                                          00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00
# Partition entry 2
#[7DD0]
                                          00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00
# Partition entry 3
                                          00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00
# Partition entry 4
                                          00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00
#[7DFE]
# This is the DOS/MBR identifier at offset 510:
55 AA
