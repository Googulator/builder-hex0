# Builder-Hex0 is a small bootable machine image which has
# the ability to compile hex0 code. It is also written in hex0
# and so it can build itself if provided with its own source code.
#
# hex0 is a "language" for binary encoding in hexadecimal
# with support for comments.

# --- stage 1
# _start
# [global data]
# halt
# reboot
#
# console_putc_16
# console_put_hex_16
# console_puts_16
#
# get_partition_start_16
# get_drive_geometry
# next_sector
# read_sectors_16
#
# mbr_main

# --- stage 2
# kern_main
# [GDT data]
# start_32bit_main
# setup_interrupt_handlers
# stub_interrupt_handler
# enter_16bit_real
# resume_32bit_mode
#
# console_putc
# console_put_hex
# console_puts
# get_partition_start
# read_sectors
#
# syscall_interrupt_handler
# handle_syscall_open
# find_file
# handle_syscall_read
# handle_syscall_brk
# handle_syscall_write
# handle_syscall_execve
# handle_syscall_waitpid
# handle_syscall_exit
#
# --- "User Mode"
# strcmp
# read
# write
# read_line
# write_line
# src
# hex0
# app_main


#------------------------------------------------------------
# Memory:
#4000000 -        processes
# 500000 -3FFFFFF files
# 401800 - 4FFC00 file names 6..1023
# 401400 - 4017FF file name 5
# 401000 - 4013FF file name 4
# 400010 - 400FF0 file lengths 4*1022
# 300000 - 3FFFFF io buffers/free
# 200800 - 2FFFFF cmd arg3..1024 (1022 args * 1K)
# 200400 - 2007FF cmd arg2 (1K)
# 200000 - 2003FF cmd arg1 (1K)
# 100000 - 1FFFF0 32 bit stack (1M)
#  9FC00 -  FFFFF BIOS
#  40000 -  9FBFF device buffers
#  20000 -  3FFFF process descriptors
#  10800 -  1FFFF opened file descriptors (16 bytes each)
#  10000 -  10800 interrupt table
#   A000 -   A1FF sector read buffer - 16bit
#   7C00 -   8600 code
#   7B00 -   7BFF Saved 32 bit registers while in 16 bit mode
# < 7B00          real mode stack
#------------------------------------------------------------


# ------------------------------------------------------------
# Stub Entry Point
#
# boot drive is in dl
#
#[7C00][13]
#:_start

# We cannot be sure the registers are initialized to zero so we
# do that first. We far jump to mbr_main in order to set CS.
31 C0           # xor ax, ax
8E D8           # COPY_AX_to_DS
8E C0           # COPY_AX_to_ES
FA              # cli               ;  cli/sti necessary on 8088
8E D0           # COPY_AX_to_SS
BC 00 7B        # mov sp, 0x7B00
FB              # sti
FC              # CLD ; clear direction flag

EA 48 7D 00 00  # jmp mbr_main


# ------------------------------------------------------------
# Global Data
#[7C13]
80     # boot_drive
0F     # boot drive max_head  0..15 
3F     # boot drive num_sectors / track (1..63)


#[7C16][0B]
#H  a  l  t  i  n  g  .  .  . \0
48 61 6C 74 69 6E 67 2E 2E 2E 00

#[7C21][0D]
#R  e  b  o  o  t  i  n  g  .  .  . \0
52 65 62 6F 6F 74 69 6E 67 2E 2E 2E 00

#[7C2E][11]
#N  o     s  o  u  r  c  e    f   o  u  n  d  . \0
4E 6F 20 73 6F 75 72 63 65 20 66 6F 75 6E 64 2E 00

#[7C3F][10]
#B  u  i  l  d     f  i  n  i  s  h  e  d  . \0
42 75 69 6C 64 20 66 69 6E 69 73 68 65 64 2E 00

#[7C4F][8]
# available
00 00 00 00 00 00 00 00


# ------------------------
#[7C57]
#:halt
#
F4      # hlt
EB FD   # jmp halt

# ------------------------
#[7C5A]
#:reboot
#
EA F0 FF 00 F0  # ljmp $F000:FFF0

# ------------------------
#[7C5F][16]
#:console_putc_16(al=c)
#
# Note: with QEMU+Seabios this does not flush the last character or
# CRLF of a line until the first character is output on the next line
# and that character cannot be another CRLF.
53        # PUSH_BX
50        # PUSH_AX

# Prepare to use BIOS tty output interrupt.
# Specify text page 00, 0 black background, 7 light grey text
BB 00 07  # LOADI16_BX 0007
# Specify the `write character` BIOS routine
B4 0E     # LOADI8_AH  0E

3C 0A     # cmp al, 0A
75 06     # jne regular

# convert LF to CR LF for BIOS output
B0 0D     # mov al, 0D
CD 10     # INT_10
B0 0A     # mov al, 0A

#:regular:
CD 10     # INT_10

58        # POP_AX
5B        # POP_BX
CB        # RETF

#[7C75][31]
#:console_put_hex_16(al=byte)
50              # PUSH_AX

24 F0           # and al, 0xF0
C0 E8 04        # shr al, 4
3C 09           # cmp al, 9
7F 04           # jg alpha
#10

#numeral:
04 30           # add al, 0x30
EB 02           # jmp print1

#alpha:
04 37           # add al, 0x37
#16

#print1:
9A 5F 7C 00 00  # CALL 00007C5F  call console_putc_16

58              # POP_AX        ; restore original al
50              # PUSH_AX       ;

24 0F           # and al, 0x0F
3C 09           # cmp al, 9
7F 04           # jg alpha
#29

#numeral:
04 30           # add al, 0x30
EB 02           # jmp print2

#alpha:
04 37           # add al, 0x37
#35

#print2:
9A 5F 7C 00 00  # CALL 00007C5F  call console_putc_16

B0 0A           # mov al, 0x0a
9A 5F 7C 00 00  # CALL 00007C5F  call console_putc_16

58              # POP_AX
CB              # retf


# ------------------------
#[7CA6][14]
#:console_puts_16 (ds:si = string)
#:puts_16_loop
#
AC              # lodsb  al=[ds:si++]
84 C0           # test al, al
74 07           # jz end_loop
9A 5F 7C 00 00  # CALL 00007C5F  call console_putc_16
EB F4           # jmp puts_16_loop

#:end_loop
B0 0A           # mov al, 0A
9A 5F 7C 00 00  # CALL 00007C5F  call console_putc_16
CB              # RETF


#[7CBA][16]
# ------------------------
#:get_partition_start_16(al=partition_num 1..4)
#returns:
# cx = cylinder/sector
# dh = head
#
50              # PUSH_AX
56              # PUSH_SI

BB 10 00        # mov bx, 0x0010     ; bx = partition_length
30 E4           # xor ah, ah
F7 E3           # mul bx             ; entry_offset = partition_num * bx
89 C6           # mov si, ax         ; si = entry_offset
BB AF 7D        # mov bx, 7DAF       ; bx = &partition_table[-1]
8A 30           # mov dh, [bx+si]    ; dh = head = partition_table[al][0]
8B 48 01        # mov cx, [bx+si+1]  ; cx = cyl/sector = partition_table[al][1]

5E              # POP_SI
58              # POP_AX
CB              # retf


#[7CD0][18]
# ------------------------
#:get_drive_geometry(dl)
#
06              # PUSH_ES
57              # PUSH_DI

# https://en.wikipedia.org/wiki/INT_13H#INT_13h_AH=08h:_Read_Drive_Parameters
31 FF           # xor di, di
8E C7           # mov es, di
B4 08           # mov ah, 8       ; get drive parameters
CD 13           # INT_13

88 36 14 7C     # mov 0x7C14, dh
80 E1 3F        # and cl, 0x3f
88 0E 15 7C     # mov 0x7C15, cl

5F              # POP_DI
07              # POP_ES
CB              # retf


#[7CE8][37]
# ------------------------
#:next_sector(cx=cylinder/sector, dh = head)
#
50              # PUSH_AX

88 C8           # mov al, cl          ; get sector number
24 3F           # and al, 0x3f
3C 3F           # cmp al, 0x3f        ; if sector_num == 63
74 04           # jz next_head        ;      goto next_head
FE C1           # inc cl              ; else sector_num++;
EB 28           # jmp cleanup

#next_head:
3A 36 14 7C     # cmp dh, [0x7C14]    ; if head_num == max_head
74 09           # jz next_cylinder    ;      goto next_cyclinder
FE C6           # inc dh              ; else head_num++
80 E1 C0        # and cl, 0xc0        ;      sector_num = 1
FE C1           # inc cl              ;
EB 19           # jmp cleanup

#next_cylinder:
80 FD FF        # cmp ch, 0xff        ; if cylinder_low == 255
74 0B           # je next_cyl_high

#next_cyl_low:
30 F6           # xor dh, dh          ; head_num = 0
80 E1 C0        # and cl, 0xc0        ; sector_num = 0
81 C1 01 01     # add cx, 0x0101      ; cylinder_low++, sector_num++
EB 09           # jmp cleanup

#next_cyl_high:
30 F6           # xor dh, dh          ; head_num = 0
81 C1 C0 00     # and cx, 0x00C0      ; cylinder_low = 0, sector_num = 0
80 C1 41        # add cl, 0x41        ; cylinder_high++, sector_num++

#cleanup:
58              # POP_AX
CB              # retf


#[7D1F][29]
#:read_sectors_16(di = *dest_addr, cx=cylinder/sector, dh = head, ax=num_sectors)
#
# returns: di - next byte to write to
#          cx,dh - next disk sector to read from
#
50              # PUSH_AX
53              # PUSH_BX
56              # PUSH_SI

89 C6            # mov si, ax      ; si=num_sectors
89 FB            # mov bx, di      ; int 13 writes to bx

#:read_one_loop
8A 16 13 7C     # mov dl, [0x7C13] ; boot disk
B4 02           # mov ah, 2       ; rw mode = 02 (read)
B0 01           # mov al, 1       ; num_sectors
CD 13           # INT_13
72 F4           # jnc read_one_loop
3C 01           # cmp al, 1
75 F0           # jnz read_one_loop

#19
# advance and maybe continue
9A E8 7C 00 00  # call next_sector

# we read one sector, advance
81 C3 00 02     # add bx, 0x200
#28
4E              # dec si          ; num_sectors--
75 E4           # jnz read_one_loop

89 DF           # mov di, bx

5E              # POP_SI
5B              # POP_BX
58              # POP_AX
CB              # RETF
#37


#[7D48][19]
#:mbr_main (dl=boot_drive)
# Load the kernel and jump to it
88 16 13 7C     # mov 0x7C13, dl   ; save boot drive
9A D0 7C 00 00  # CALL get_drive_geometry()
BF 00 7E        # mov di, 0x7E00   ; place kernel after MBR in memory
B8 06 00        # mov ax, 0x0006   ; num_sectors = 6
B9 02 00        # LOADI16_CX 0002  ; cylinder = 0, sector_num = 0x02
B6 00           # LOADI8_DH 00     ; head = 0
9A 1F 7D 00 00  # call read_sectors_16
EA 00 7E 00 00  # JMP 00007E00  jmp kern_main


# ------------------------------------------------------------
# This is the rest of the MBR.
#
#[7D  ]
                  00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
#[7D80]
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
#[7DB0]
00 00 00 00 00 00 00 00 00 00 00 00 00 00

# Partition entry 1
#[7DBE]
# status inactive
00
# first head,sector[0..5]+cylinder[8..9],cylinder[0..7]
00 01 00
# type non-fs data
DA
# last head,sector[0..5]+cylinder[8..9],cylinder[0..7]
00 00 00
# LBA start
00 00 00 00
# Num sectors
00 00 00 00

# Partition entry 2
#[7DCE]
# status inactive
00
# first head,sector[0..5]+cylinder[8..9],cylinder[0..7]
00 02 00
# type "non-fs data"
DA
# last head,sector[0..5]+cylinder[8..9],cylinder[0..7]
00 00 00
# LBA start
00 00 00 00
# Num sectors
00 00 00 00

# Partition entry 3
# status inactive
00
# first head,sector[0..5]+cylinder[8..9],cylinder[0..7]
00 03 00
# type "non-fs data"
DA
# last head,sector[0..5]+cylinder[8..9],cylinder[0..7]
00 00 00
# LBA start
00 00 00 00
# Num sectors
00 00 00 00

# Partition entry 4
# status inactive
00
# first head,sector[0..5]+cylinder[8..9],cylinder[0..7]
00 08 00
# type "non-fs data"
DA
# last head,sector[0..5]+cylinder[8..9],cylinder[0..7]
00 00 00
# LBA start
00 00 00 00
# Num sectors
00 00 00 00

#[7DFE]
# This is the DOS/MBR identifier at offset 510:
55 AA

#------------------------------------------------------------
# The kernel entry point
#------------------------------------------------------------
#:kern_main
#[7E00][14]

EA 36 7E 00 00  # JMP jmp start_32bit_main

# alignment
90 90 90

#---------------------------------------------
# The Global Descriptor Table for 32 bit mode.
#---------------------------------------------
#[7E08]
#:GDT_start:
00 00 00 00 00 00 00 00

#7E10 [+08]
#:GDT_code32:
FF FF # limit 0:15
00 00 # base  0:15
00    # base 16:23
9A    # access byte 10011010b
      #   present=1 privilege=00 type=1
      #   code=1 conforming=0 readable=1 accessed=0
CF    # 11001111b
      #   granularity=1 32-bit-default=1 64-bit seg=0 AVL=0
00    #

#7E18 [+10]
#:GDT_data32:
FF FF # limit 0:15
00 00 # base  0:15
00    # base 16:23
92    # access byte 10010010b 
      #   present=1 privilege=00 type=1
      #   code=0 conforming=0 readable=1 accessed=0
CF    # flags, limit 16:19 11001111b  
      #   granularity=1 32-bit-default=1 64-bit seg=0 AVL=0
00    # base 24:31

#7E20 [+18]
#:GDT_code16:
FF FF # limit 0:15
00 00 # base  0:15
00    # base 16:23
9A    # access byte 10011010b
      #   present=1 privilege=00 type=1
      #   code=1 conforming=0 readable=1 accessed=0
8F    # 10001111b
      #   granularity=1 32-bit-default=0 64-bit seg=0 AVL=0
00    #

#7E28 [+20]
#:GDT_data16:
FF FF # limit 0:15
00 00 # base  0:15
00    # base 16:23
92    # access byte 10010010b 
      #   present=1 privilege=00 type=1
      #   code=0 conforming=0 readable=1 accessed=0
8F    # flags, limit 16:19 10001111b  
      #   granularity=1 32-bit-default=0 64-bit seg=0 AVL=0
00    # base 24:31

#7E30
#:GDT_locator
27 00        #  length
08 7E 00 00  #  GDT_start


# ------------------------------------------------------------
# Kernel Functions
# ------------------------------------------------------------

#----------------------------------------
#[7E36][3D]
#:start_32bit_main()
B8 01 24              # mov ax,2401h     # enable A20 line
CD 15                 # int 15h

FA                    # cli
0F 01 16 30 7E        # lgdt GDT_locator
0F 20 C0              # mov eax, cr0
66 83 C8 01           # or eax, 0x01
0F 22 C0              # mov cr0, eax
EA 50 7E 08 00        # JMP jmp setup_32bit
#[7E50][@1A][23]
#:setup_32bit
66 B8 10 00           # mov ax, 0x0010      ; data descriptor
8E D8                 # mov ds, ax
8E D0                 # mov ss, ax
8E C0                 # mov es, ax
8E E0                 # mov fs, ax
8E E8                 # mov gs, ax
BD 0F FF 1F 00        # mov ebp, 0x1FFFF0
89 EC                 # mov esp, ebp

9A 73 7E 00 00 08 00  # call setup_interrupt_handlers
9A 62 87 00 00 08 00  # call app_main


#----------------------------------------
#[7E73][40]
#:setup_interrupt_handlers
53                    # push ebx

# handle the timer interrupt 08
BB 40 00 01 00        # mov ebx, &interrupt_table[08]
66 C7 03 B9 7E        # mov word [ebx + 0], low_address stub_interrupt_handler
66 C7 43 06 00 00     # mov word [ebx + 6], high_address
66 C7 43 02 08 00     # mov word [ebx + 2], code_segment = 0x0800
C6 43 05 8E           # mov byte [ebx + 5], flags = 8E

# handle int 80
BB 00 04 01 00        # mov ebx, &interrupt_table[80]
66 C7 03 C8 7F        # mov word [ebx + 0], low_address syscall_interrupt_handler
66 C7 43 06 00 00     # mov word [ebx + 6], high_address
66 C7 43 02 08 00     # mov word [ebx + 2], code_segment = 0x0800
C6 43 05 8E           # mov byte [ebx + 5], flags = 8E

# load the interrupt table
FA                    # cli
0F 01 1D B3 7E 00 00  # lidt [0x00007EB3] IDT_locator_32
FB                    # sti
5B                    # pop ebx
CB                    # retf


#----------------------------------------
#[7EB3][06]
#:IDT_locator_32
FF 07        #  length
00 00 01 00  #  IDT_start


#----------------------------------------
#stub_interrupt_handler
#[7EB9]
CF                    # iret


#------------------------------------------------------------
# 32 -> 16 -> 32 bit switching functions
#------------------------------------------------------------
# When switching between real mode and
# protected, registers are stored here:
#
# 7B14  edx
# 7B10
# 7B0C
# 7B08  eax
# 7B04  esp
#
# 7B00  <- top of real mode stack


#----------------------------------------
#[7EBA][61]
#:enter_16bit_real
FA                    # cli
A3 08 7B 00 00        # mov [0x7B08], eax  ; preserve so we can use these locally
89 15 14 7B 00 00     # mov [0x7B14], edx  ;
5A                    # pop edx            ; capture return address
89 25 04 7B 00 00     # mov [0x7B04], esp  ; capture stack

# The following far jump sets CS to a 16-bit protected mode selector
# and the segment registers are also set to 16-bit protected mode selectors.
# This is done prior to entering real mode.
EA D4 7E 00 00 18 00  # jmp 0x18:setup_16bit
#[7ED4]
#:setup_16bit
B8 20 00              # mov eax, 0x0020
8E D0                 # mov ss, eax
8E D8                 # mov ds, eax
8E C0                 # mov es, eax
8E E8                 # mov gs, eax
8E E0                 # mov fs, eax
BC 00 7B              # mov sp, 0x7B00
0F 20 C0              # mov eax, cr0
66 83 E0 FE           # and eax, 0xfffffffe  ; clear protected mode
0F 22 C0              # mov cr0, eax
# The following far jump sets CS to a 16-bit real mode segment
# and the segment registers are also set to real mode segments.
EA F3 7E 00 00        # jmp 0000:XXXX  real_mode
#[7EF3]
#:real_mode
B8 00 00              # mov ax, 0x0
8E D8                 # mov ds, ax
8E E0                 # mov fs, ax
8E E8                 # mov gs, ax
8E D0                 # mov ss, ax
8E C0                 # mov es, ax
BC 00 7B              # mov sp, 0x7B00
FA                    # cli
0F 01 1E 15 7F        # lidt IDT
FB                    # sti
# Using retf to set CS comes from here:
# https://stackoverflow.com/questions/26448480/bios-interrupts-in-protected-mode
# This page recommends a far jump followed by sti:
# https://www.sudleyplace.com/pmtorm.html
6A 00                 # push 0x0000 (2 bytes!)  CS to return to
52                    # push dx  IP to return to
A1 08 7B              # mov ax, [0x7B08]  ; restore from above
8B 16 14 7b           # mov dx, [0x7B14]
CB                    # retf

# IDT
#[7F15]
FF FF
00 00 00 00


#----------------------------------------
#[7F1B][40]
#:resume_32bit_mode()
FA                    # cli
A3 08 7B              # mov [0x7B08], ax  ; preserve, they might be return values from 16 bit
89 16 14 7b           # mov [0x7B14], dx
5A                    # pop dx      ; carry the return IP in dx
58                    # pop ax      ; CS
0F 01 16 30 7E        # lgdt GDT_locator
0F 20 C0              # mov eax, cr0
66 83 C8 01           # or eax, 0x01         ; enable protected mode
0F 22 C0              # mov cr0, eax
EA 39 7F 08 00        # JMP restore_32bit
#[7F39]
#:restore_32bit
B8 10 00 00 00        # mov eax, 0x0010      ; data descriptor
8E D8                 # mov ds, eax
8E D0                 # mov ss, eax
8E C0                 # mov es, eax
8E E0                 # mov fs, eax
8E E8                 # mov gs, eax
8B 25 04 7B 00 00     # mov esp, [0x7B04]   ; restore, (saved in enter_16bit_mode)
9A 73 7E 00 00 08 00  # call setup_interrupt_handlers
52                    # push edx            ; setup our return location
# These restore the 16 bit portion of these registers, which may be a
# return value from a 16 bit function, and they also restore any previous high
# bits that were stored by enter_16bit_mode so these registers need not be
# saved when going to 16 bit mode and back if you want them left alone.
A1 08 7B 00 00        # mov eax, [0x7B08]   ; restore, (saved at top of this function)
8B 15 14 7B 00 00     # mov edx, [0x7B14]
C3                    # ret


# ------------------------
#[7F62][10]
#:console_putc:
#
E8 53 FF FF FF  # CALL enter_16bit_real, next=[7F67]
9A 5F 7C 00 00  # CALL console_putc_16(al)
9A 1B 7F 00 00  # CALL resume_32bit_mode
CB              # RETF


# ------------------------
#:console_put_hex
#[7F72][10]
E8 43 FF FF FF  # CALL enter_16bit_real, next=[7F77]
9A 75 7C 00 00  # CALL console_put_hex_16(al)
9A 1B 7F 00 00  # CALL resume_32bit_mode
CB              # RETF


# ------------------------
#[7F82][1A]
#:console_puts (ds:si = string)
#:puts_loop
50                    # push eax
56                    # push esi
8A 06                 # mov al, [esi]
3C 00                 # cmp al, 0
74 0A                 # jz end_loop
9A 62 7F 00 00 08 00  # call console_putc
46                    # inc esi
EB F0                 # jmp puts_loop
#:end_loop
B0 0A                 # mov al, 0A
9A 62 7F 00 00 08 00  # call console_putc
5E                    # pop esi
58                    # pop eax
CB                    # RETF


#[7FA0][18]
# ------------------------
#:get_partition_start(eax=partition_num 1..4)
#returns:
# cx = cylinder/sector
# dh = head
#
50              # PUSH_EAX
56              # PUSH_ESI

6B C0 10        # imul eax, 0x10
89 c6           # mov esi, eax         ; esi = entry_offset
BB AE 7D 00 00  # mov ebx, 7DAE        ; ebx = &partition_table[-1]
8A 74 33 01     # mov dh, [ebx+esi+1]  ; dh = head = partition_table[al][0]
66 8B 4C 33 02  # mov cx, [ebx+esi+2]  ; cx = cyl/sector = partition_table[al][1]

5E              # POP_ESI
58              # POP_EAX
CB              # retf


# ------------------------
#[7FB8][10]
#:read_sectors(di = *dest_addr, cx=cylinder/sector, dh = head, ax=num_sectors)
E8 FD FE FF FF  # CALL enter_16bit_real, next=[7FBD]
9A 1F 7D 00 00  # CALL read_sectors_16
9A 1B 7F 00 00  # CALL resume_32bit_mode
CB              # RETF


# ------------------------
#[7FC8][29]
#:syscall_interrupt_handler
83 F8 01              # cmp eax, 1
75 08                 # jne try next
9A C9 83 00 00 08 00  # call handle_syscall_exit
CF                    # iret

83 F8 02              # cmp eax, 2
75 08                 # jne try next
9A 79 82 00 00 08 00  # call handle_syscall_fork
CF                    # iret

83 F8 03              # cmp eax, 3
75 08                 # jne try next
9A 1A 81 00 00 08 00  # call handle_syscall_read
CF                    # iret

83 F8 04              # cmp eax, 4
75 08                 # jne try next
9A 23 82 00 00 08 00  # call handle_syscall_write
CF                    # iret

83 F8 05              # cmp eax, 5
75 08                 # jne try next
9A 4D 80 00 00 08 00  # call handle_syscall_open
CF                    # iret

83 F8 07              # cmp eax, 7
75 08                 # jne try next
9A B3 83 00 00 08 00  # call handle_syscall_waitpid
CF                    # iret

83 F8 0B              # cmp eax, B
75 08                 # jne try next
9A BB 82 00 00 08 00  # call handle_syscall_execve
CF                    # iret

83 F8 13              # cmp eax, 0x13
75 08                 # jne try next
9A 21 84 00 00 08 00  # call handle_syscall_lseek
CF                    # iret

83 F8 2D              # cmp eax, 2D
75 07                 # jne ret
9A D5 81 00 00 08 00  # call handle_syscall_brk
CF                    # iret


#[803D][08]
#s  c  /  o  p  e  n \0
73 63 2F 6F 70 65 6E 00

#[8045][04]
# next_filenum
04 00 00 00

#[8049][04]
# next_file_address
00 00 50 00

#------------------------------------------------------------
#[804D][20]
#:handle_syscall_open(ebx=filename, ecx=flags)
56                    # push esi
57                    # push edi
51                    # push ecx

BE 3D 80 00 00        # mov esi, "sc/open"
9A 82 7F 00 00 08 00  # call console_puts

89 DE                 # mov esi, ebx
9A 82 7F 00 00 08 00  # call console_puts

F7 C1 01 00 00 00     # test ecx, 1
74 52                 # jz open_read

# copy filename to new slot
89 DE                 # mov esi, ebx
BF 00 00 40 00        # mov edi, 0x0400000
A1 45 80 00 00        # mov eax, [&next_filenum]
C1 E0 0A              # shl eax, 0a
01 C7                 # add edi, eax
B9 00 04 00 00        # mov ecx, 0x0000400
F3 A4                 # rep movsb

# set address of file
BF 00 08 01 00        # mov edi, 0x0010800            ; pfile_descriptor = &file_descriptor[0]
A1 45 80 00 00        # mov eax, [&next_filenum]
C1 E0 04              # shl eax, 04
01 C7                 # add edi, eax                  ; pfile_descriptor += sizeof(file_descriptor) * next_filenum
8B 0D 49 80 00 00     # mov ecx, [next_file_address]
C7 01 00 00 00 00     # mov long [ecx], 0             ; *next_addr = 0  (put a zero between files, not really necessary?)
41                    # inc ecx
89 0D 49 80 00 00     # mov [next_file_address], ecx  ; next_file_addr++
89 4F 04              # mov [edi+4], ecx              ; pfile_descriptor->file_addr = ecx
C7 47 08 00 00 00 00  # mov long [edi+8], 0           ; pfile_descriptor->length = 0

A1 45 80 00 00        # mov eax, [next_filenum]
40                    # inc eax
A3 45 80 00 00        # mov [next_filenum], eax  ; next_filenum++
48                    # dec eax
EB 18                 # jmp finish

#open_read
9A E2 80 00 00 08 00  # call find_file
89 C1                 # mov ecx, eax
# set read offset to start of file
BE 00 08 01 00        # mov esi, 0x0010800       ; pfile_descriptor = &file_descriptor[0]
C1 E1 04              # shl ecx, 04
01 CE                 # add esi, ecx             ; pfile_descriptor += sizeof(file_descriptor) * filenum
31 C9                 # xor ecx, ecx
89 4E 0C              # mov [esi+0xC], ecx       ; current offset = 0

# finish
9A 72 7F 00 00 08 00  # call console_put_hex
59                    # pop ecx
5F                    # pop edi
5E                    # pop esi
CB                    # ret


#----------------------------------------
#[80E2]
#:find_file(char * ebx=file_name) returns eax=filenum
51                    # push ecx
52                    # push edx
56                    # push esi
57                    # push edi

BA 04 00 00 00        # mov edx, 4              ; filenum = 4
#check file
89 DE                 # mov esi, ebx

BF 00 00 40 00        # mov edi, 0x0400000      ; pfile_name = &file_name[0]
89 D0                 # mov eax, edx
C1 E0 0A              # shl eax, 0a
01 C7                 # add edi, eax            ; pfile_name += sizeof(file_name) * filenum

9A 60 84 00 00 08 00  # call strcmp
74 11                 # je match

# if not on last file, continue checking
42                    # inc edx
A1 45 80 00 00        # mov eax, [next_filenum]
39 C2                 # cmp edx, eax
75 DF                 # jne checkfile

#no match
B8 FF FF FF FF        # mov eax, 0xffffffff
EB 02                 # jmp finish

#match
89 D0                 # mov eax, edx

#finish
5F                    # pop edi
5E                    # pop esi
5A                    # pop edx
59                    # pop ecx
CB                    # ret


#------------------------------------------------------------
#[811A][70]
#:handle_syscall_read(ecx=*return_char, ebx=file, edx=length)
53                    # push ebx
51                    # push ecx
52                    # push edx
56                    # push esi
57                    # push edi

51                    # push ecx   ; we need this later to return char
83 FB 00              # cmp ebx, 0
75 6A                 # jne memfile

# stdin is /dev/hda4
# get current position
66 8B 0D 00 08 01 00  # mov cx, [0x10800]  ; cyl/sector
8A 35 02 08 01 00     # mov dh, [0x10802]  ; head
31 C0                 # xor eax, eax
66 A1 04 08 01 00     # mov ax, [0x10804]  ; offset
#end of sector?
66 3D ff 01           # cmp ax, 0x01ff
74 04                 # je next sector

#nextchar:
66 40                 # inc ax
EB 2A                 # jmp getchar

#read next sector
BF 00 A0 00 00        # mov edi, 0x000A000
B8 01 00 00 00        # mov eax, 0x0001   ; num_sectors = 1
9A B8 7F 00 00 08 00  # call read_sectors

# save new location and offset
66 89 0D 00 08 01 00  # mov [0x10800], cx
88 35 02 08 01 00     # mov [0x10802], dh
31 C0                 # xor eax, eax

# move block to device buffer
BE 00 A0 00 00        # mov esi, 0x000A000
BF 00 00 04 00        # mov edi, 0x0040000
B9 00 02 00 00        # mov ecx, 0x0000200
F3 A4                 # rep movsb

#getchar:
66 A3 04 08 01 00     # mov [0x10804], ax
59                    # pop ecx
BB 00 00 04 00        # mov ebx, 0x40000    ; device buffer
89 C6                 # mov esi, eax        ; offset
8A 04 33              # mov al, [ebx+esi+0]
88 01                 # mov [ecx], al
B8 01 00 00 00        # mov eax, 1
EB 3C                 # jmp finish

#memfile:

# get descriptor address
BE 00 08 01 00        # mov esi, 0x0010800     ; pfile_descriptor = &file_descriptor[0]
89 D9                 # mov ecx, ebx
C1 E1 04              # shl ecx, 04
01 CE                 # add esi, ecx           ; pfile_descriptor += sizeof(file_descriptor) * filenum


# prepare to read
31 C0                 # xor eax, eax            ; bytes_read = 0
5F                    # pop edi                 ; edi = p_dst
8B 5E 04              # mov ebx, [esi+4]        ; ebx = pfile_descriptor->file_address
89 D9                 # mov ecx, ebx            ;
03 4E 08              # add ecx, [esi+0x08]     ; ecx = file_address + length
49                    # dec ecx                 ; ecx = last address to read
03 5E 0C              # add ebx, [esi+0xC]      ; ebx = file_addr + current_offset
87 F3                 # xchg esi, ebx           ; esi = p_src

# read_loop
39 CE                 # cmp esi, ecx            ; past the end?
7F 1B                 # jg finish

# Debug: examine the reads from a specific file
#81 fb 80 09 01 00     # cmp ebx, 0x10840
#75 0B                 # jne skip
#50                    # push eax
##8B 06                 # mov eax, [esi]
#9A 62 7F 00 00 08 00  # call console_putc
#58                    # pop eax
90 90 90 90 90 90
90 90
90
90 90
90 90 90 90 90 90 90
90

A4                    # movsb
40                    # inc eax                 ; bytes_read++
FF 43 0C              # inc long [ebx+0xC]      ; pfile_descriptor->current_offset++
4A                    # dec edx
75 E1                 # jnz read_loop

#finish:
5F                    # pop edi
5E                    # pop esi
5A                    # pop edx
59                    # pop ecx
5B                    # pop ebx
CB                    # ret


#[81D1]
#b  r  k
62 72 6b 00

#[81D5]
#------------------------------------------------------------
#:handle_syscall_brk
56                    # push esi
BE D1 81 00 00        # mov esi, &"brk"
#9A 82 7F 00 00 08 00  # call console_puts
90 90 90 90 90 90 90

A1 B3 82 00 00        # mov eax, [&next_process_num]
48                    # dec eax = current process

BE 00 00 02 00        # mov esi, 0x0020000       ; pproc_descriptor = &proc_descriptor[0]
C1 E0 08              # shl eax, 08
01 C6                 # add esi, eax             ; pproc_descriptor += sizeof(proc_descriptor) * procnum

85 DB                 # test ebx, ebx
74 13                 # jz get

# set
# initialize memory to zero
57                    # push edi
31 C0                 # xor eax, eax
8B 7E 04              # mov edi, [esi+4]
#init_loop
AA                    # stosb
39 DF                 # cmp edi, ebx
75 FB                 # jne init_loop
5F                    # pop edi

89 5E 04              # mov [esi+4], ebx
89 D8                 # mov eax, ebx
5E                    # pop esi
CB                    # ret

# get
8B 46 04              # mov eax, [esi+4]         ; pproc_descriptor->brk
5E                    # pop esi
CB                    # ret


90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
90 90 90 90 90


#------------------------------------------------------------
#[8223]
#:handle_syscall_write(ebx=file,ecx=*char_to_write)
51                    # push ecx
52                    # push edx
56                    # push esi
57                    # push edi

# stdout?
83 FB 01              # cmp ebx, 01
75 0B                 # jnz memfile

# stdout -> console_out
8A 01                 # mov al, [ecx]
9A 62 7F 00 00 08 00  # call console_putc
EB 38                 # jmp finish

#:memfile
C1 E3 04              # shl ebx, 04
81 C3 00 08 01 00     # add ebx, 0x010800       ; pfile_descriptor += sizeof(file_descriptor) * filenum
# prepare to write
89 CE                 # mov esi, ecx
8b 7b 04              # mov edi, [ebx+4]        ; ebx = pfile_descriptor->file_address
03 7B 0C              # add edi, [ebx+0xC]      ; ebx = file_addr + current_offset
31 C0                 # xor eax, eax            ; bytes_written = 0
#write_loop

# Debug: examine the writes to a specific file
#81 fb 40 0B 01 00     # cmp ebx, 0x10880
#75 0B
#50                    # push eax
#8B 06                 # mov eax, [esi]
#9A 72 7F 00 00 08 00  # call console_put_hex
#58                    # pop eax
90 90 90 90 90 90
90 90
90
90 90
90 90 90 90 90 90 90
90

A4                    # movsb
FF 43 0C              # inc long [ebx+0xC]   ; current_offset++
FF 43 08              # inc long [ebx+0x8]   ; file_length++
FF 05 49 80 00 00     # inc long [next_file_addr]
40                    # inc eax              ; num_written++
4A                    # dec edx
75 DC                 # jnz write_loop

90

#finish
5F                    # pop edi
5E                    # pop esi
5A                    # pop edx
59                    # pop ecx
CB                    # ret


#[8274]
#f  o  r  k
66 6F 72 6B 00

#[8279]
#:handle_syscall_fork
56                    # push esi
57                    # push edi

BE 74 82 00 00        # mov esi, "fork"
9A 82 7F 00 00 08 00  # call console_puts


A1 B3 82 00 00        # mov eax, [&next_process_num]
48                    # dec eax = current process
BF 00 00 02 00        # mov edi, 0x0020000       ; pproc_descriptor = &proc_descriptor[0]
C1 E0 08              # shl eax, 08
01 C7                 # add edi, eax             ; pproc_descriptor += sizeof(proc_descriptor) * procnum

89 E6                 # mov esi, esp
89 77 0c              # mov [edi+0xC], esi       ; save stack pointer so we can return again later

83 C7 10              # add edi, 0x10
B9 20 00 00 00        # mov ecx, 0x20
F3 A5                 # rep movsd                ; save stack

31 C0                 # xor eax, eax             ; return as child, we'll return again as parent when child exits
5F                    # pop edi
5E                    # pop esi
CB                    # ret


#[82AB]
#s  c  /  e  x  e  c
73 63 2F 65 78 65 63 00

#[82B3][04]
# next_process_num
01 00 00 00

#[82B7][04]
# next_process_address
00 00 00 04

#----------------------------------------
#[82BB]
#:handle_syscall_execve (ebx = program_name, ecx = char **args, edx=env)
BE AB 82 00 00        # mov esi, "sc/exec"
9A 82 7F 00 00 08 00  # call console_puts

BE 00 00 02 00        # mov esi, 0x0020000       ; pproc_descriptor = &proc_descriptor[0]
A1 B3 82 00 00        # mov eax, [&next_process_num]
9A 72 7F 00 00 08 00  # call console_put_hex
C1 E0 08              # shl eax, 08
01 C6                 # add esi, eax             ; pproc_descriptor += sizeof(proc_descriptor) * procnum
89 66 08              # mov [esi+0x8], esp       ; save original stack pointer before pushing args

6A 00                 # push 0             ; env; TODO use edx
# count args
31 C0                 # xor eax, eax       ; passed_args = 0
# countloop
83 39 00              # cmp long [ecx], 0
74 06                 # jz pushloop
40                    # inc eax
83 C1 04              # add ecx, 4
EB F5                 # jmp countloop

# push args in reverse
89 C2                 # mov edx, eax
#pushloop
83 E9 04              # sub ecx, 4
FF 31                 # push long [ecx]

8B 31                 # mov esi, [ecx]
9A 82 7F 00 00 08 00  # call console_puts

48                    # dec eax
75 EF                 # jnz pushloop
89 D0                 # mov eax, edx

#finish
50                    # push eax = argc
9A E2 80 00 00 08 00  # call find_file

# get file address and length
BA 00 08 01 00        # mov edx, 0x0010800       ; pfile_descriptor = &file_descriptor[0]
C1 E0 04              # shl eax, 04
01 C2                 # add edx, eax             ; pfile_descriptor += sizeof(file_descriptor) * filenum
8B 4A 08              # mov ecx, [edx+0x8]       ; ecx = pfile_descriptor->file_length

8B 72 04              # mov esi, [edx+0x4]       ; esi = pfile_descriptor->file_address

# get proc entry point from file image
8B 46 3C              # mov eax, [esi + 0x3C]    ; get declared process address
25 FF FF 00 00        # and eax, 0x0000FFFF      ; mask off high bits to get local addr

# calc process image beginning
8B 3D B7 82 00 00     # mov edi, [&next_process_address]
09 C7                 # or edi, eax              ; use low bits from declared entry point

51                    # push ecx
57                    # push edi
F3 A4                 # rep movsb
5F                    # pop edi
59                    # pop ecx

# record process in proc descriptor
BE 00 00 02 00        # mov esi, 0x0020000       ; pproc_descriptor = &proc_descriptor[0]
A1 B3 82 00 00        # mov eax, [&next_process_num]
50                    # push eax
C1 E0 08              # shl eax, 08
01 C6                 # add esi, eax             ; pproc_descriptor += sizeof(proc_descriptor) * procnum
58                    # pop eax

89 3E                 # mov [esi], edi           ; pproc_descriptor->address = edi

57                    # push edi
01 CF                 # add edi, ecx             ; set brk after code
81 c7 00 01 00 00     # add edi, 0x00010000
89 7E 04              # mov [esi+4], edi         ; pproc_descriptor->brk
5F                    # pop edi

# prepare for next process
40                    # inc eax
A3 B3 82 00 00        # mov [next_process_num], eax
57                    # push edi
81 C7 00 00 D0 00     # add edi, 0xD00000
89 3D B7 82 00 00     # mov [&next_process_address], edi
5F                    # pop edi

# patch locations
57                    # push edi
89 FB                 # mov ebx, edi             ; new process address
C1 EB 10              # shr ebx, 16              ; mov high bytes to bx


66 3b 5f 18           # cmp bx, [edi + 0x18]     ; already at right location?
74 11                 # je patch_elf_start

#:patch_all
8B 07                 # mov eax, [edi]
66 3d 04 08           # cmp ax, 0x0804
75 05                 # jne next
#:patch:
66 89 1F              # mov [edi], bx
47                    # inc edi
49                    # dec ecx
#next:
47                    # inc edi
49                    # dec ecx
75 EF                 # jnz patch_all
EB 11                 # jmp done

#patch_elf_start
8B 07                 # mov eax, [edi]
3d 00 80 04 08        # cmp eax, elf_start
75 0E                 # jne next
#:patch:
66 89 5f 02           # mov [edi+2], bx
#next:
47                    # inc edi
49                    # dec ecx
75 EF                 # jnz patch_elf_start

#:done
5F                    # pop edi

# get entry point and jump
ff 77 18              # push [edi + 0x18]
31 C0                 # xor eax, eax
31 DB                 # xor ebx, ebx
31 C9                 # xor ecx, ecx
31 D2                 # xor edx, edx
31 F6                 # xor esi, esi
31 FF                 # xor edi, edi
31 ED                 # xor ebp, ebp
C3                    # ret


90 90


#----------------------
#[83AB][08]
#w  a  i  t  p  i  d \0
77 61 69 74 70 69 64 00

#----------------------------------------
#:handle_syscall_waitpid
#[83B3]
BE AB 83 00 00        # mov esi, "waitpid"
9A 82 7F 00 00 08 00  # call console_puts
31 C0                 # xor eax, eax
89 01                 # mov [ecx], eax
CB                    # ret


#[83C4]
#e  x  i  t \0
65 78 69 74 00

#----------------------------------------
#:handle_syscall_exit
#[83C9]
BE C4 83 00 00        # mov esi, "exit"
9A 82 7F 00 00 08 00  # call console_puts

89 D8                 # mov eax, ebx
9A 72 7F 00 00 08 00  # call console_put_hex
85 C0                 # test eax, eax
74 02                 # jz okexit

FA F4                 # cli;hlt

#:okexit
A1 B7 82 00 00        # mov eax, [&next_process_address]
2d 00 00 d0 00        # sub eax,  0xD00000
A3 B7 82 00 00        # mov [&next_process_address], eax

A1 B3 82 00 00        # mov eax, [&next_process_num]
48                    # dec eax = current process
A3 B3 82 00 00        # mov [&next_process_num], eax
48                    # dec eax = parent process

BE 00 00 02 00        # mov esi, 0x0020000       ; pproc_descriptor = &proc_descriptor[0]
C1 E0 08              # shl eax, 08
01 C6                 # add esi, eax
8b 66 0c              # mov esp, [esi+0xc]

83 C6 10              # add esi, 0x10
89 E7                 # mov edi, esp
B9 20 00 00 00        # mov ecx, 0x20
F3 A5                 # rep movsd

# mimic syscall_fork's finish
5F                    # pop edi
5E                    # pop esi

CB                    # ret


#[841B]
#lseek
6C 73 65 65 6B 00

#[8421]
#handle_syscall_lseek
90 # 50                    # push eax
56                    # push esi

BE 1B 84 00 00        # mov esi, "lseek"
9A 82 7F 00 00 08 00  # call console_puts
89 D8                 # mov eax, ebx
9A 72 7F 00 00 08 00  # call console_put_hex
BE 00 08 01 00        # mov esi, 0x0010800       ; pfile_descriptor = &file_descriptor[0]
C1 E0 04              # shl eax, 04
01 C6                 # add esi, eax

83 FA 01              # cmp edx, 1
7F 05                 # jg seek_end
89 4E 0C              # mov [esi+0xC], ecx       ; set current offset
EB 11                 # jmp done

#:seek_end
8B 46 08              # mov eax, [esi+0x8]        ; get current_length
01 C8                 # add eax, ecx              ; current_length += offset
89 46 08              # mov [esi+0x8], eax        ; set current_length
89 46 0C              # mov [esi+0xc], eax        ; set current_pos
01 0D 49 80 00 00     # add [next_file_addr], ecx

#done
5E                    # pop esi
90 # 58                    # pop eax
CB                    # ret


# ------------------------------------------------------------
# Utilities
# ------------------------------------------------------------

#:strcmp(esi, edi) returns zf
#[8460]
50                    # push eax
53                    # push ebx
56                    # push esi
57                    # push edi

#check_byte
8A 06                 # mov al, [esi]
8A 1F                 # mov bl, [edi]
38 D8                 # cmp al, bl
75 0A                 # jne finish
46                    # inc esi
47                    # inc edi
84 C0                 # test al, al
75 F2                 # jnz check_byte
84 DB                 # test bl, bl
75 EE                 # jnz check_byte

#finish
5F                    # pop edi
5E                    # pop esi
5B                    # pop ebx
58                    # pop eax
CB                    # ret


# ----------------------------------------
# variables for read
#
#[847B]  char io_char
00
00  # free

#[847D][26]
#:read
53                    # push ebx
51                    # push ecx
52                    # push edx
B8 03 00 00 00        # mov eax, 3   ; syscall=read
B9 7B 84 00 00        # mov ecx, &io_char
BA 01 00 00 00        # mov edx, 1

CD 80                 # int 80 syscall

3C 00                 # cmp al, 0
74 07                 # je finish

B4 01                 # mov ah, 1
A0 7B 84 00 00        # mov al, &io_char

#finish
5A                    # pop edx
59                    # pop ecx
5B                    # pop ebx
CB                    # ret


#[84A0][26]
#:write
50                    # push eax
53                    # push ebx
51                    # push ecx
52                    # push edx

A2 7B 84 00 00        # mov &io_char, al
B8 04 00 00 00        # mov eax, 4   ; syscall=write
B9 7B 84 00 00        # mov ecx, &io_char
BA 01 00 00 00        # mov edx, 1   1 byte characters
CD 80                 # int 80 syscall

5A                    # pop edx
59                    # pop ecx
5B                    # pop ebx
58                    # pop eax
CB                    # ret


#[84BF][0F]
#:read_line(ebx=file, edi=linemem)
50                    # push eax
9A 7D 84 00 00 08 00  # call read
AA                    # stosb
3C 0A                 # cmp al, '\n'
75 F4                 # jne read_line
58                    # pop eax
CB                    # ret


#[84CE][0F]
#:write_line(ebx=file, esi=linemem)
50                    # push eax
#write_char
AC                    # lodsb
9A A0 84 00 00 08 00  # call write
3C 0A                 # cmp al, '\n'
75 F4                 # jne write_char

58                    # pop eax
CB                    # ret


#[84DD][04]
#s  r  c \0
73 72 63 00

#----------------------------------------
# src: create file from stdin
#
# Read an integer, N, in decimal from stdin.
# Read a space.
# Then, read a file name to create.
# Read a newline.
# Then, read N lines from stdin and write to the new file.
#[84DF]
#:src
50                    # push eax
53                    # push ebx
51                    # push ecx
52                    # push edx
56                    # push esi
57                    # push edi

31 C9                 # xor ecx, ecx        ; line count=0

90 90

BE DD 84 00 00        # mov esi,  "src"
9A 82 7F 00 00 08 00  # call console_puts

9A 7D 84 00 00 08 00  # call read 'r'
9A 7D 84 00 00 08 00  # call read 'c'
9A 7D 84 00 00 08 00  # call read ' '

#parse_line_count_loop:
9A 7D 84 00 00 08 00  # call read
3C 20                 # cmp al, ' '
74 0C                 # je got count

6B C9 0A              # imul ecx, ecx, 10   ; count = count * 10
2C 30                 # sub al, 30
0F B6 C0              # movzx eax, al
01 C1                 # add ecx, eax        ; count += digit

EB E9                 # jmp parse_line_count_loop

# got_count:
88 E8                 # mov al, ch
9A 72 7F 00 00 08 00  # call put_hex
88 C8                 # mov al, cl
9A 72 7F 00 00 08 00  # call put_hex

# clear arguments
51                    # push ecx
31 C0                 # xor eax, eax
BA 00 00 20 00        # mov edx, 0x00200000
B9 00 08 00 00        # mov ecx, 0x00000800
90
#zeroloop
88 02                 # mov [edx], al
42                    # inc edx
49                    # dec ecx
75 FA                 # jnz zeroloop
59                    # pop ecx

90 90 90 90
90 90 90 90
90 90

51                    # push ecx
B9 00 00 20 00        # mov ecx, 0x00200000
# get_filename_loop:
9A 7D 84 00 00 08 00  # call read

90 90 90 90 90 90 90
90 90

3C 0A                 # cmp al, '\n'
74 05                 # je got_filename
88 01                 # mov [ecx], al
41                    # inc ecx
EB E7                 # jmp get_file_name_loop
59                    # pop ecx

# got_filename:
BE 00 00 20 00        # mov esi, 0x00200000
9A 82 7F 00 00 08 00  # call console_puts

# open filename for write
51                    # push ecx
BB 00 00 20 00        # mov ebx, 0x00200000
B8 05 00 00 00        # mov eax, 5  ; syscall_open
B9 41 02 00 00        # mov ecx, 0x00000241 O_TRUNC (0x200) | O_CREAT (0x40) | O_WRONLY (0x1)
BA 80 01 00 00        # mov edx, 0x00000180 S_IRUSR (0x100) | S_IWUSR (0x80)
CD 80                 # int 80
59                    # pop ecx

# eax has the open file number

# readwrite_loop:
BF 00 00 30 00        # mov edi, 0x00300000   ; io buffer
31 DB                 # xor ebx, ebx   ; ebx=0=stdin
9A BF 84 00 00 08 00  # call read_line
89 C3                 # mov ebx, eax          # prepare to write
BE 00 00 30 00        # mov esi, 0x00300000
9A CE 84 00 00 08 00  # call write_line
49                    # dec ecx   ; count--
75 E1                 # jnz read_write_loop

5F                    # pop edi
5E                    # pop esi
5A                    # pop edx
59                    # pop ecx
5B                    # pop ebx
58                    # pop eax
CB                    # ret


#[85BE][05]
#h  e  x  0 \0
68 65 78 30 00

#------------------------------------------------------------
#:hex0
#[85C3]
53                    # push ebx
56                    # push esi
57                    # push edi

BE BE 85 00 00        # mov esi,  "hex0"
9A 82 7F 00 00 08 00  # call console_puts
9A 7D 84 00 00 08 00  # call read 'e'
9A 7D 84 00 00 08 00  # call read 'x'
9A 7D 84 00 00 08 00  # call read '0'
9A 7D 84 00 00 08 00  # call read ' '

# clear arguments
31 C0                 # xor eax, eax
BA 00 00 20 00        # mov edx, 0x00200000
B9 00 08 00 00        # mov ecx, 0x00000800
#zeroloop
88 02                 # mov [edx], al
42                    # inc edx
49                    # dec ecx
75 FA                 # jnz zeroloop

BA 00 00 20 00        # mov edx, 0x00200000
#get_file_name1_loop
9A 7D 84 00 00 08 00  # call read
3C 20                 # cmp al, ' '
74 05                 # je got_filename1
88 02                 # mov [edx], al
42                    # inc edx
EB F0                 # jmp get_file_name_loop

#got_filename1
BA 00 04 20 00        # mov edx, 0x00200400
#get_file_name2_loop
9A 7D 84 00 00 08 00  # call read
3C 0A                 # cmp al, '\n'
74 05                 # je got_filename2
88 02                 # mov [edx], al
42                    # inc edx
EB F0                 # jmp get_file_name_loop

# open filename1 for read
BB 00 00 20 00        # mov ebx, 0x00200000
B8 05 00 00 00        # mov eax, 5  ; syscall_open
B9 00 00 00 00        # mov ecx, 0x00000000
CD 80                 # int 80

50                    # push eax  ; save read filenum

# open filename2 for write
BB 00 04 20 00        # mov ebx, 0x00200400
B8 05 00 00 00        # mov eax, 5  ; syscall_open
B9 41 02 00 00        # mov ecx, 0x00000241 O_TRUNC (0x200) | O_CREAT (0x40) | O_WRONLY (0x1)
BA 80 01 00 00        # mov edx, 0x00000180 S_IRUSR (0x100) | S_IWUSR (0x80)
CD 80                 # int 80
89 C2                 # mov edx, eax

59                    # pop ecx                 ; restore read filenum

# this flag is set after the first digit is seen
31 DB                 # xor ebx, ebx


#[8657]
#:read_loop
53                    # push ebx
89 CB                 # mov ebx, ecx
9A 7D 84 00 00 08 00  # call read
5B                    # pop ebx
#f5

#9A 72 7F 00 00 08 00  # call put_hex
90 90 90 90 90 90 90
90 90 90 90

84 e4                 # test ah, ah
75 04                 # jnz check_command
5F                    # POP_DI
5E                    # POP_SI
5B                    # POP_BX
CB                    # RETF

#:check_command
3C 23                 # cmp al, '#'

#cf
74 28                 # jz skip_comment

3C 3B                 # cmp ';'
74 24                 # jz skip_comment

3C 66                 # cmp al, 'f'
7F C6                 # jg read_loop

3C 61                 # cmp al, 'a'
7C 04                 # jl maybe_upper

# Handle a to f
2C 57                 # sub al, 'a'-10 == 87 = 0x57
EB 29                 # jmp maybe_store

#:maybe_upper
3C 46                 # cmp al, 'F'
7F CA                 # jg read_loop

3C 41                 # cmp al, 'A'
7C 04                 # jl maybe_digit

# Handle A to F
2C 37                 # sub al, 'A'-10 == 55 = x37
EB 1D                 # jmp maybe_store

#:maybe_digit
3C 39                 # cmp al, '9'
7F BE                 # jg read_loop

3C 30                 # cmp al, '0'
7C BA                 # jl read_loop

# Handle 0 to 9
2C 30                 # sub al, '0' == x30
EB 11                 # jmp maybe_store

#:skip_comment
53                    # push ebx
89 CB                 # mov ebx, ecx
9A 7D 84 00 00 08 00  # call read
5B                    # pop ebx
3C 0A                 # cmp al, '\n'
75 F1                 # jnz skip_comment
EB A5                 # jmp read_loop

# only store on second digit
#:maybe_store
84 DB                 # test bl, bl
75 09                 # jnz second_digit

# If on first digit, record and keep going
#:first_digit
C0 E0 04              # shl al, 4
88 C7                 # mov bh, al
FE C3                 # inc bl
EB 98                 # jmp read_loop

# If on second digit, store and clear state
#:second_digit
08 C7                 # or bh, al
88 F8                 # mov al, bh

53                    # push ebx
89 D3                 # mov ebx, edx
9A A0 84 00 00 08 00  # call write
5B                    # pop ebx

31 DB                 # xor bx, bx
EA 57 86 00 00 08 00  # jmp read_loop


#[86D7]
#[cmd_args]
00 00 20 00
00 04 20 00
00 00 00 00

#------------------------------------------------------------
#:handle_other_command
#[86E3]
BE AB 82 00 00        # mov esi, "sc/exec"
9A 82 7F 00 00 08 00  # call console_puts

# clear arguments
BA 00 00 20 00        # mov edx, 0x00200000
88 02                 # mov [edx], al
42                    # inc edx
31 C0                 # xor eax, eax
B9 FF 07 00 00        # mov ecx, 0x000007FF
#zeroloop
88 02                 # mov [edx], al
42                    # inc edx
49                    # dec ecx
75 FA                 # jnz zeroloop

BA 01 00 20 00        # mov edx, 0x00200001
#get_program_name
9A 7D 84 00 00 08 00  # call read
3C 20                 # cmp al, ' '
74 05                 # je got_program_name
88 02                 # mov [edx], al
42                    # inc edx
EB F0                 # jmp get_program_name

#got_program_name
BA 00 04 20 00        # mov edx, 0x00200400
#get_file_name2_loop
9A 7D 84 00 00 08 00  # call read
3C 0A                 # cmp al, '\n'
74 05                 # je got_filename2
88 02                 # mov [edx], al
42                    # inc edx
EB F0                 # jmp get_file_name_loop

BE 00 00 20 00        # mov esi, program
9A 82 7F 00 00 08 00  # call console_puts

BE 00 04 20 00        # mov esi, arg1
9A 82 7F 00 00 08 00  # call console_puts

BB 00 00 20 00        # mov ebx, program_name
B9 D7 86 00 00        # mov ecx, cmd_args
9A BB 82 00 00 08 00  # call handle_syscall_execve   ; does not return

CB

90 90 90 90 90 90 90
#9A 72 7F 00 00 08 00  # call put_hex
00 00 00

#[8762]
# ------------------------------------------------------------
# Main Program Body
# ------------------------------------------------------------
#:app_main (dl=boot_drive)
# Set up /dev/hda4 as global stdin
B8 04 00 00 00        # mov eax, 4
9A A0 7F 00 00 08 00  # call get_partition_start(4)

# save disk location and byte offset to descriptor
66 89 0D 00 08 01 00  # mov [0x10800], cx
88 35 02 08 01 00     # mov [0x10802], dh
# start at "end of sector" to trigger an initial sector read
66 B9 FF 01           # mov cx, 0x01FF
66 89 0D 04 08 01 00  # mov [0x10804], cx

# read from stdin
31 DB                 # xor ebx, ebx

#:process_command:
9A 7D 84 00 00 08 00  # call read
3C 00                 # cmp al, 0           ; check_end
74 23                 # je finish_success

#check_src_command
3C 73                 # cmp al, 's'
75 09                 # jne check_hex0

#handle_src_command
9A DF 84 00 00 08 00  # call src
EB E8                 # jmp process_command

#check_hex0_command
3C 68                 # cmp al, 'h'
75 09                 # jne handle_other_command

#handle_hex0_command
9A C3 85 00 00 08 00  # call hex0
EB DB                 # jmp process_command

#handle_other_command:
#gather_other_command:
9A E3 86 00 00 08 00  # call handle_other_command
EB D2                 # jmp process_command

#finish_success
#zero source
#call reboot
#:error_exit
BE 3F 7C 00 00        # mov esi, "Build finished."
9A 82 7F 00 00 08 00  # call console_puts

BE 16 7C 00 00        # mov esi, "Halting..."
9A 82 7F 00 00 08 00  # call console_puts

# one space to flush last line
B0 20                 # mov al, 20
9A 62 7F 00 00 08 00  # call console_putc

FA F4

# END Program Body

00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
#[8800]
